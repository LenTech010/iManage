import {
  EMPTY_OBJ,
  NO,
  NOOP,
  PatchFlagNames,
  camelize,
  capitalize,
  extend,
  generateCodeFrame,
  hyphenate,
  init_runtime_dom_esm_bundler,
  init_shared_esm_bundler,
  isArray,
  isBuiltInDirective,
  isHTMLTag,
  isObject,
  isOn,
  isReservedProp,
  isSVGTag,
  isString,
  isSymbol,
  isVoidTag,
  makeMap,
  parseStringStyle,
  runtime_dom_esm_bundler_exports,
  shared_esm_bundler_exports,
  slotFlagsText,
  toHandlerKey
} from "./chunk-6XECGMJ4.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-CF3WPAMV.js";

// node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js
function defaultOnError(error) {
  throw error;
}
function defaultOnWarn(msg) {
  console.warn(`[Vue warn] ${msg.message}`);
}
function createCompilerError(code, loc, messages, additionalMessage) {
  const msg = true ? (messages || errorMessages)[code] + (additionalMessage || ``) : code;
  const error = new SyntaxError(String(msg));
  error.code = code;
  error.loc = loc;
  return error;
}
function registerRuntimeHelpers(helpers) {
  Object.getOwnPropertySymbols(helpers).forEach((s) => {
    helperNameMap[s] = helpers[s];
  });
}
function createRoot(children, loc = locStub) {
  return {
    type: 0,
    children,
    helpers: /* @__PURE__ */ new Set(),
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: 0,
    temps: 0,
    codegenNode: void 0,
    loc
  };
}
function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent2 = false, loc = locStub) {
  if (context) {
    if (isBlock) {
      context.helper(OPEN_BLOCK);
      context.helper(getVNodeBlockHelper(context.inSSR, isComponent2));
    } else {
      context.helper(getVNodeHelper(context.inSSR, isComponent2));
    }
    if (directives) {
      context.helper(WITH_DIRECTIVES);
    }
  }
  return {
    type: 13,
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent: isComponent2,
    loc
  };
}
function createArrayExpression(elements, loc = locStub) {
  return {
    type: 17,
    loc,
    elements
  };
}
function createObjectExpression(properties, loc = locStub) {
  return {
    type: 15,
    loc,
    properties
  };
}
function createObjectProperty(key, value) {
  return {
    type: 16,
    loc: locStub,
    key: isString(key) ? createSimpleExpression(key, true) : key,
    value
  };
}
function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0) {
  return {
    type: 4,
    loc,
    content,
    isStatic,
    constType: isStatic ? 3 : constType
  };
}
function createInterpolation(content, loc) {
  return {
    type: 5,
    loc,
    content: isString(content) ? createSimpleExpression(content, false, loc) : content
  };
}
function createCompoundExpression(children, loc = locStub) {
  return {
    type: 8,
    loc,
    children
  };
}
function createCallExpression(callee, args = [], loc = locStub) {
  return {
    type: 14,
    loc,
    callee,
    arguments: args
  };
}
function createFunctionExpression(params, returns = void 0, newline = false, isSlot = false, loc = locStub) {
  return {
    type: 18,
    params,
    returns,
    newline,
    isSlot,
    loc
  };
}
function createConditionalExpression(test, consequent, alternate, newline = true) {
  return {
    type: 19,
    test,
    consequent,
    alternate,
    newline,
    loc: locStub
  };
}
function createCacheExpression(index, value, isVNode = false) {
  return {
    type: 20,
    index,
    value,
    isVNode,
    loc: locStub
  };
}
function createBlockStatement(body) {
  return {
    type: 21,
    body,
    loc: locStub
  };
}
function createTemplateLiteral(elements) {
  return {
    type: 22,
    elements,
    loc: locStub
  };
}
function createIfStatement(test, consequent, alternate) {
  return {
    type: 23,
    test,
    consequent,
    alternate,
    loc: locStub
  };
}
function createAssignmentExpression(left, right) {
  return {
    type: 24,
    left,
    right,
    loc: locStub
  };
}
function createSequenceExpression(expressions) {
  return {
    type: 25,
    expressions,
    loc: locStub
  };
}
function createReturnStatement(returns) {
  return {
    type: 26,
    returns,
    loc: locStub
  };
}
function getVNodeHelper(ssr, isComponent2) {
  return ssr || isComponent2 ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
}
function getVNodeBlockHelper(ssr, isComponent2) {
  return ssr || isComponent2 ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
}
function convertToBlock(node, { helper, removeHelper, inSSR }) {
  if (!node.isBlock) {
    node.isBlock = true;
    removeHelper(getVNodeHelper(inSSR, node.isComponent));
    helper(OPEN_BLOCK);
    helper(getVNodeBlockHelper(inSSR, node.isComponent));
  }
}
function isCoreComponent(tag) {
  if (isBuiltInType(tag, "Teleport")) {
    return TELEPORT;
  } else if (isBuiltInType(tag, "Suspense")) {
    return SUSPENSE;
  } else if (isBuiltInType(tag, "KeepAlive")) {
    return KEEP_ALIVE;
  } else if (isBuiltInType(tag, "BaseTransition")) {
    return BASE_TRANSITION;
  }
}
function getInnerRange(loc, offset, length) {
  const source = loc.source.slice(offset, offset + length);
  const newLoc = {
    source,
    start: advancePositionWithClone(loc.start, loc.source, offset),
    end: loc.end
  };
  if (length != null) {
    newLoc.end = advancePositionWithClone(
      loc.start,
      loc.source,
      offset + length
    );
  }
  return newLoc;
}
function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
  return advancePositionWithMutation(
    extend({}, pos),
    source,
    numberOfCharacters
  );
}
function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
  let linesCount = 0;
  let lastNewLinePos = -1;
  for (let i = 0; i < numberOfCharacters; i++) {
    if (source.charCodeAt(i) === 10) {
      linesCount++;
      lastNewLinePos = i;
    }
  }
  pos.offset += numberOfCharacters;
  pos.line += linesCount;
  pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;
  return pos;
}
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg || `unexpected compiler condition`);
  }
}
function findDir(node, name, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 7 && (allowEmpty || p.exp) && (isString(name) ? p.name === name : name.test(p.name))) {
      return p;
    }
  }
}
function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 6) {
      if (dynamicOnly)
        continue;
      if (p.name === name && (p.value || allowEmpty)) {
        return p;
      }
    } else if (p.name === "bind" && (p.exp || allowEmpty) && isStaticArgOf(p.arg, name)) {
      return p;
    }
  }
}
function isStaticArgOf(arg, name) {
  return !!(arg && isStaticExp(arg) && arg.content === name);
}
function hasDynamicKeyVBind(node) {
  return node.props.some(
    (p) => p.type === 7 && p.name === "bind" && (!p.arg || // v-bind="obj"
    p.arg.type !== 4 || // v-bind:[_ctx.foo]
    !p.arg.isStatic)
    // v-bind:[foo]
  );
}
function isText$1(node) {
  return node.type === 5 || node.type === 2;
}
function isVSlot(p) {
  return p.type === 7 && p.name === "slot";
}
function isTemplateNode(node) {
  return node.type === 1 && node.tagType === 3;
}
function isSlotOutlet(node) {
  return node.type === 1 && node.tagType === 2;
}
function getUnnormalizedProps(props, callPath = []) {
  if (props && !isString(props) && props.type === 14) {
    const callee = props.callee;
    if (!isString(callee) && propsHelperSet.has(callee)) {
      return getUnnormalizedProps(
        props.arguments[0],
        callPath.concat(props)
      );
    }
  }
  return [props, callPath];
}
function injectProp(node, prop, context) {
  let propsWithInjection;
  let props = node.type === 13 ? node.props : node.arguments[2];
  let callPath = [];
  let parentCall;
  if (props && !isString(props) && props.type === 14) {
    const ret = getUnnormalizedProps(props);
    props = ret[0];
    callPath = ret[1];
    parentCall = callPath[callPath.length - 1];
  }
  if (props == null || isString(props)) {
    propsWithInjection = createObjectExpression([prop]);
  } else if (props.type === 14) {
    const first = props.arguments[0];
    if (!isString(first) && first.type === 15) {
      if (!hasProp(prop, first)) {
        first.properties.unshift(prop);
      }
    } else {
      if (props.callee === TO_HANDLERS) {
        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
          createObjectExpression([prop]),
          props
        ]);
      } else {
        props.arguments.unshift(createObjectExpression([prop]));
      }
    }
    !propsWithInjection && (propsWithInjection = props);
  } else if (props.type === 15) {
    if (!hasProp(prop, props)) {
      props.properties.unshift(prop);
    }
    propsWithInjection = props;
  } else {
    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
      createObjectExpression([prop]),
      props
    ]);
    if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
      parentCall = callPath[callPath.length - 2];
    }
  }
  if (node.type === 13) {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.props = propsWithInjection;
    }
  } else {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.arguments[2] = propsWithInjection;
    }
  }
}
function hasProp(prop, props) {
  let result = false;
  if (prop.key.type === 4) {
    const propKeyName = prop.key.content;
    result = props.properties.some(
      (p) => p.key.type === 4 && p.key.content === propKeyName
    );
  }
  return result;
}
function toValidAssetId(name, type) {
  return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
    return searchValue === "-" ? "_" : name.charCodeAt(replaceValue).toString();
  })}`;
}
function hasScopeRef(node, ids) {
  if (!node || Object.keys(ids).length === 0) {
    return false;
  }
  switch (node.type) {
    case 1:
      for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 7 && (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {
          return true;
        }
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 11:
      if (hasScopeRef(node.source, ids)) {
        return true;
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 9:
      return node.branches.some((b) => hasScopeRef(b, ids));
    case 10:
      if (hasScopeRef(node.condition, ids)) {
        return true;
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 4:
      return !node.isStatic && isSimpleIdentifier(node.content) && !!ids[node.content];
    case 8:
      return node.children.some((c) => isObject(c) && hasScopeRef(c, ids));
    case 5:
    case 12:
      return hasScopeRef(node.content, ids);
    case 2:
    case 3:
      return false;
    default:
      if (true)
        ;
      return false;
  }
}
function getMemoedVNodeCall(node) {
  if (node.type === 14 && node.callee === WITH_MEMO) {
    return node.arguments[1].returns;
  } else {
    return node;
  }
}
function getCompatValue(key, context) {
  const config = context.options ? context.options.compatConfig : context.compatConfig;
  const value = config && config[key];
  if (key === "MODE") {
    return value || 3;
  } else {
    return value;
  }
}
function isCompatEnabled(key, context) {
  const mode = getCompatValue("MODE", context);
  const value = getCompatValue(key, context);
  return mode === 3 ? value === true : value !== false;
}
function checkCompatEnabled(key, context, loc, ...args) {
  const enabled = isCompatEnabled(key, context);
  if (enabled) {
    warnDeprecation(key, context, loc, ...args);
  }
  return enabled;
}
function warnDeprecation(key, context, loc, ...args) {
  const val = getCompatValue(key, context);
  if (val === "suppress-warning") {
    return;
  }
  const { message, link } = deprecationData[key];
  const msg = `(deprecation ${key}) ${typeof message === "function" ? message(...args) : message}${link ? `
  Details: ${link}` : ``}`;
  const err = new SyntaxError(msg);
  err.code = key;
  if (loc)
    err.loc = loc;
  context.onWarn(err);
}
function baseParse(content, options = {}) {
  const context = createParserContext(content, options);
  const start = getCursor(context);
  return createRoot(
    parseChildren(context, 0, []),
    getSelection(context, start)
  );
}
function createParserContext(content, rawOptions) {
  const options = extend({}, defaultParserOptions);
  let key;
  for (key in rawOptions) {
    options[key] = rawOptions[key] === void 0 ? defaultParserOptions[key] : rawOptions[key];
  }
  return {
    options,
    column: 1,
    line: 1,
    offset: 0,
    originalSource: content,
    source: content,
    inPre: false,
    inVPre: false,
    onWarn: options.onWarn
  };
}
function parseChildren(context, mode, ancestors) {
  const parent = last(ancestors);
  const ns = parent ? parent.ns : 0;
  const nodes = [];
  while (!isEnd(context, mode, ancestors)) {
    const s = context.source;
    let node = void 0;
    if (mode === 0 || mode === 1) {
      if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {
        node = parseInterpolation(context, mode);
      } else if (mode === 0 && s[0] === "<") {
        if (s.length === 1) {
          emitError(context, 5, 1);
        } else if (s[1] === "!") {
          if (startsWith(s, "<!--")) {
            node = parseComment(context);
          } else if (startsWith(s, "<!DOCTYPE")) {
            node = parseBogusComment(context);
          } else if (startsWith(s, "<![CDATA[")) {
            if (ns !== 0) {
              node = parseCDATA(context, ancestors);
            } else {
              emitError(context, 1);
              node = parseBogusComment(context);
            }
          } else {
            emitError(context, 11);
            node = parseBogusComment(context);
          }
        } else if (s[1] === "/") {
          if (s.length === 2) {
            emitError(context, 5, 2);
          } else if (s[2] === ">") {
            emitError(context, 14, 2);
            advanceBy(context, 3);
            continue;
          } else if (/[a-z]/i.test(s[2])) {
            emitError(context, 23);
            parseTag(context, TagType.End, parent);
            continue;
          } else {
            emitError(
              context,
              12,
              2
            );
            node = parseBogusComment(context);
          }
        } else if (/[a-z]/i.test(s[1])) {
          node = parseElement(context, ancestors);
          if (isCompatEnabled(
            "COMPILER_NATIVE_TEMPLATE",
            context
          ) && node && node.tag === "template" && !node.props.some(
            (p) => p.type === 7 && isSpecialTemplateDirective(p.name)
          )) {
            warnDeprecation(
              "COMPILER_NATIVE_TEMPLATE",
              context,
              node.loc
            );
            node = node.children;
          }
        } else if (s[1] === "?") {
          emitError(
            context,
            21,
            1
          );
          node = parseBogusComment(context);
        } else {
          emitError(context, 12, 1);
        }
      }
    }
    if (!node) {
      node = parseText(context, mode);
    }
    if (isArray(node)) {
      for (let i = 0; i < node.length; i++) {
        pushNode(nodes, node[i]);
      }
    } else {
      pushNode(nodes, node);
    }
  }
  let removedWhitespace = false;
  if (mode !== 2 && mode !== 1) {
    const shouldCondense = context.options.whitespace !== "preserve";
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (node.type === 2) {
        if (!context.inPre) {
          if (!/[^\t\r\n\f ]/.test(node.content)) {
            const prev = nodes[i - 1];
            const next = nodes[i + 1];
            if (!prev || !next || shouldCondense && (prev.type === 3 && next.type === 3 || prev.type === 3 && next.type === 1 || prev.type === 1 && next.type === 3 || prev.type === 1 && next.type === 1 && /[\r\n]/.test(node.content))) {
              removedWhitespace = true;
              nodes[i] = null;
            } else {
              node.content = " ";
            }
          } else if (shouldCondense) {
            node.content = node.content.replace(/[\t\r\n\f ]+/g, " ");
          }
        } else {
          node.content = node.content.replace(/\r\n/g, "\n");
        }
      } else if (node.type === 3 && !context.options.comments) {
        removedWhitespace = true;
        nodes[i] = null;
      }
    }
    if (context.inPre && parent && context.options.isPreTag(parent.tag)) {
      const first = nodes[0];
      if (first && first.type === 2) {
        first.content = first.content.replace(/^\r?\n/, "");
      }
    }
  }
  return removedWhitespace ? nodes.filter(Boolean) : nodes;
}
function pushNode(nodes, node) {
  if (node.type === 2) {
    const prev = last(nodes);
    if (prev && prev.type === 2 && prev.loc.end.offset === node.loc.start.offset) {
      prev.content += node.content;
      prev.loc.end = node.loc.end;
      prev.loc.source += node.loc.source;
      return;
    }
  }
  nodes.push(node);
}
function parseCDATA(context, ancestors) {
  advanceBy(context, 9);
  const nodes = parseChildren(context, 3, ancestors);
  if (context.source.length === 0) {
    emitError(context, 6);
  } else {
    advanceBy(context, 3);
  }
  return nodes;
}
function parseComment(context) {
  const start = getCursor(context);
  let content;
  const match = /--(\!)?>/.exec(context.source);
  if (!match) {
    content = context.source.slice(4);
    advanceBy(context, context.source.length);
    emitError(context, 7);
  } else {
    if (match.index <= 3) {
      emitError(context, 0);
    }
    if (match[1]) {
      emitError(context, 10);
    }
    content = context.source.slice(4, match.index);
    const s = context.source.slice(0, match.index);
    let prevIndex = 1, nestedIndex = 0;
    while ((nestedIndex = s.indexOf("<!--", prevIndex)) !== -1) {
      advanceBy(context, nestedIndex - prevIndex + 1);
      if (nestedIndex + 4 < s.length) {
        emitError(context, 16);
      }
      prevIndex = nestedIndex + 1;
    }
    advanceBy(context, match.index + match[0].length - prevIndex + 1);
  }
  return {
    type: 3,
    content,
    loc: getSelection(context, start)
  };
}
function parseBogusComment(context) {
  const start = getCursor(context);
  const contentStart = context.source[1] === "?" ? 1 : 2;
  let content;
  const closeIndex = context.source.indexOf(">");
  if (closeIndex === -1) {
    content = context.source.slice(contentStart);
    advanceBy(context, context.source.length);
  } else {
    content = context.source.slice(contentStart, closeIndex);
    advanceBy(context, closeIndex + 1);
  }
  return {
    type: 3,
    content,
    loc: getSelection(context, start)
  };
}
function parseElement(context, ancestors) {
  const wasInPre = context.inPre;
  const wasInVPre = context.inVPre;
  const parent = last(ancestors);
  const element = parseTag(context, TagType.Start, parent);
  const isPreBoundary = context.inPre && !wasInPre;
  const isVPreBoundary = context.inVPre && !wasInVPre;
  if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {
    if (isPreBoundary) {
      context.inPre = false;
    }
    if (isVPreBoundary) {
      context.inVPre = false;
    }
    return element;
  }
  ancestors.push(element);
  const mode = context.options.getTextMode(element, parent);
  const children = parseChildren(context, mode, ancestors);
  ancestors.pop();
  {
    const inlineTemplateProp = element.props.find(
      (p) => p.type === 6 && p.name === "inline-template"
    );
    if (inlineTemplateProp && checkCompatEnabled(
      "COMPILER_INLINE_TEMPLATE",
      context,
      inlineTemplateProp.loc
    )) {
      const loc = getSelection(context, element.loc.end);
      inlineTemplateProp.value = {
        type: 2,
        content: loc.source,
        loc
      };
    }
  }
  element.children = children;
  if (startsWithEndTagOpen(context.source, element.tag)) {
    parseTag(context, TagType.End, parent);
  } else {
    emitError(context, 24, 0, element.loc.start);
    if (context.source.length === 0 && element.tag.toLowerCase() === "script") {
      const first = children[0];
      if (first && startsWith(first.loc.source, "<!--")) {
        emitError(context, 8);
      }
    }
  }
  element.loc = getSelection(context, element.loc.start);
  if (isPreBoundary) {
    context.inPre = false;
  }
  if (isVPreBoundary) {
    context.inVPre = false;
  }
  return element;
}
function parseTag(context, type, parent) {
  const start = getCursor(context);
  const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
  const tag = match[1];
  const ns = context.options.getNamespace(tag, parent);
  advanceBy(context, match[0].length);
  advanceSpaces(context);
  const cursor = getCursor(context);
  const currentSource = context.source;
  if (context.options.isPreTag(tag)) {
    context.inPre = true;
  }
  let props = parseAttributes(context, type);
  if (type === 0 && !context.inVPre && props.some((p) => p.type === 7 && p.name === "pre")) {
    context.inVPre = true;
    extend(context, cursor);
    context.source = currentSource;
    props = parseAttributes(context, type).filter((p) => p.name !== "v-pre");
  }
  let isSelfClosing = false;
  if (context.source.length === 0) {
    emitError(context, 9);
  } else {
    isSelfClosing = startsWith(context.source, "/>");
    if (type === 1 && isSelfClosing) {
      emitError(context, 4);
    }
    advanceBy(context, isSelfClosing ? 2 : 1);
  }
  if (type === 1) {
    return;
  }
  if (isCompatEnabled(
    "COMPILER_V_IF_V_FOR_PRECEDENCE",
    context
  )) {
    let hasIf = false;
    let hasFor = false;
    for (let i = 0; i < props.length; i++) {
      const p = props[i];
      if (p.type === 7) {
        if (p.name === "if") {
          hasIf = true;
        } else if (p.name === "for") {
          hasFor = true;
        }
      }
      if (hasIf && hasFor) {
        warnDeprecation(
          "COMPILER_V_IF_V_FOR_PRECEDENCE",
          context,
          getSelection(context, start)
        );
        break;
      }
    }
  }
  let tagType = 0;
  if (!context.inVPre) {
    if (tag === "slot") {
      tagType = 2;
    } else if (tag === "template") {
      if (props.some(
        (p) => p.type === 7 && isSpecialTemplateDirective(p.name)
      )) {
        tagType = 3;
      }
    } else if (isComponent(tag, props, context)) {
      tagType = 1;
    }
  }
  return {
    type: 1,
    ns,
    tag,
    tagType,
    props,
    isSelfClosing,
    children: [],
    loc: getSelection(context, start),
    codegenNode: void 0
    // to be created during transform phase
  };
}
function isComponent(tag, props, context) {
  const options = context.options;
  if (options.isCustomElement(tag)) {
    return false;
  }
  if (tag === "component" || /^[A-Z]/.test(tag) || isCoreComponent(tag) || options.isBuiltInComponent && options.isBuiltInComponent(tag) || options.isNativeTag && !options.isNativeTag(tag)) {
    return true;
  }
  for (let i = 0; i < props.length; i++) {
    const p = props[i];
    if (p.type === 6) {
      if (p.name === "is" && p.value) {
        if (p.value.content.startsWith("vue:")) {
          return true;
        } else if (checkCompatEnabled(
          "COMPILER_IS_ON_ELEMENT",
          context,
          p.loc
        )) {
          return true;
        }
      }
    } else {
      if (p.name === "is") {
        return true;
      } else if (
        // :is on plain element - only treat as component in compat mode
        p.name === "bind" && isStaticArgOf(p.arg, "is") && true && checkCompatEnabled(
          "COMPILER_IS_ON_ELEMENT",
          context,
          p.loc
        )
      ) {
        return true;
      }
    }
  }
}
function parseAttributes(context, type) {
  const props = [];
  const attributeNames = /* @__PURE__ */ new Set();
  while (context.source.length > 0 && !startsWith(context.source, ">") && !startsWith(context.source, "/>")) {
    if (startsWith(context.source, "/")) {
      emitError(context, 22);
      advanceBy(context, 1);
      advanceSpaces(context);
      continue;
    }
    if (type === 1) {
      emitError(context, 3);
    }
    const attr = parseAttribute(context, attributeNames);
    if (attr.type === 6 && attr.value && attr.name === "class") {
      attr.value.content = attr.value.content.replace(/\s+/g, " ").trim();
    }
    if (type === 0) {
      props.push(attr);
    }
    if (/^[^\t\r\n\f />]/.test(context.source)) {
      emitError(context, 15);
    }
    advanceSpaces(context);
  }
  return props;
}
function parseAttribute(context, nameSet) {
  var _a;
  const start = getCursor(context);
  const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source);
  const name = match[0];
  if (nameSet.has(name)) {
    emitError(context, 2);
  }
  nameSet.add(name);
  if (name[0] === "=") {
    emitError(context, 19);
  }
  {
    const pattern = /["'<]/g;
    let m;
    while (m = pattern.exec(name)) {
      emitError(
        context,
        17,
        m.index
      );
    }
  }
  advanceBy(context, name.length);
  let value = void 0;
  if (/^[\t\r\n\f ]*=/.test(context.source)) {
    advanceSpaces(context);
    advanceBy(context, 1);
    advanceSpaces(context);
    value = parseAttributeValue(context);
    if (!value) {
      emitError(context, 13);
    }
  }
  const loc = getSelection(context, start);
  if (!context.inVPre && /^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(name)) {
    const match2 = /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(
      name
    );
    let isPropShorthand = startsWith(name, ".");
    let dirName = match2[1] || (isPropShorthand || startsWith(name, ":") ? "bind" : startsWith(name, "@") ? "on" : "slot");
    let arg;
    if (match2[2]) {
      const isSlot = dirName === "slot";
      const startOffset = name.lastIndexOf(
        match2[2],
        name.length - (((_a = match2[3]) == null ? void 0 : _a.length) || 0)
      );
      const loc2 = getSelection(
        context,
        getNewPosition(context, start, startOffset),
        getNewPosition(
          context,
          start,
          startOffset + match2[2].length + (isSlot && match2[3] || "").length
        )
      );
      let content = match2[2];
      let isStatic = true;
      if (content.startsWith("[")) {
        isStatic = false;
        if (!content.endsWith("]")) {
          emitError(
            context,
            27
          );
          content = content.slice(1);
        } else {
          content = content.slice(1, content.length - 1);
        }
      } else if (isSlot) {
        content += match2[3] || "";
      }
      arg = {
        type: 4,
        content,
        isStatic,
        constType: isStatic ? 3 : 0,
        loc: loc2
      };
    }
    if (value && value.isQuoted) {
      const valueLoc = value.loc;
      valueLoc.start.offset++;
      valueLoc.start.column++;
      valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);
      valueLoc.source = valueLoc.source.slice(1, -1);
    }
    const modifiers = match2[3] ? match2[3].slice(1).split(".") : [];
    if (isPropShorthand)
      modifiers.push("prop");
    if (dirName === "bind" && arg) {
      if (modifiers.includes("sync") && checkCompatEnabled(
        "COMPILER_V_BIND_SYNC",
        context,
        loc,
        arg.loc.source
      )) {
        dirName = "model";
        modifiers.splice(modifiers.indexOf("sync"), 1);
      }
      if (modifiers.includes("prop")) {
        checkCompatEnabled(
          "COMPILER_V_BIND_PROP",
          context,
          loc
        );
      }
    }
    return {
      type: 7,
      name: dirName,
      exp: value && {
        type: 4,
        content: value.content,
        isStatic: false,
        // Treat as non-constant by default. This can be potentially set to
        // other values by `transformExpression` to make it eligible for hoisting.
        constType: 0,
        loc: value.loc
      },
      arg,
      modifiers,
      loc
    };
  }
  if (!context.inVPre && startsWith(name, "v-")) {
    emitError(context, 26);
  }
  return {
    type: 6,
    name,
    value: value && {
      type: 2,
      content: value.content,
      loc: value.loc
    },
    loc
  };
}
function parseAttributeValue(context) {
  const start = getCursor(context);
  let content;
  const quote = context.source[0];
  const isQuoted = quote === `"` || quote === `'`;
  if (isQuoted) {
    advanceBy(context, 1);
    const endIndex = context.source.indexOf(quote);
    if (endIndex === -1) {
      content = parseTextData(
        context,
        context.source.length,
        4
      );
    } else {
      content = parseTextData(context, endIndex, 4);
      advanceBy(context, 1);
    }
  } else {
    const match = /^[^\t\r\n\f >]+/.exec(context.source);
    if (!match) {
      return void 0;
    }
    const unexpectedChars = /["'<=`]/g;
    let m;
    while (m = unexpectedChars.exec(match[0])) {
      emitError(
        context,
        18,
        m.index
      );
    }
    content = parseTextData(context, match[0].length, 4);
  }
  return { content, isQuoted, loc: getSelection(context, start) };
}
function parseInterpolation(context, mode) {
  const [open, close] = context.options.delimiters;
  const closeIndex = context.source.indexOf(close, open.length);
  if (closeIndex === -1) {
    emitError(context, 25);
    return void 0;
  }
  const start = getCursor(context);
  advanceBy(context, open.length);
  const innerStart = getCursor(context);
  const innerEnd = getCursor(context);
  const rawContentLength = closeIndex - open.length;
  const rawContent = context.source.slice(0, rawContentLength);
  const preTrimContent = parseTextData(context, rawContentLength, mode);
  const content = preTrimContent.trim();
  const startOffset = preTrimContent.indexOf(content);
  if (startOffset > 0) {
    advancePositionWithMutation(innerStart, rawContent, startOffset);
  }
  const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);
  advancePositionWithMutation(innerEnd, rawContent, endOffset);
  advanceBy(context, close.length);
  return {
    type: 5,
    content: {
      type: 4,
      isStatic: false,
      // Set `isConstant` to false by default and will decide in transformExpression
      constType: 0,
      content,
      loc: getSelection(context, innerStart, innerEnd)
    },
    loc: getSelection(context, start)
  };
}
function parseText(context, mode) {
  const endTokens = mode === 3 ? ["]]>"] : ["<", context.options.delimiters[0]];
  let endIndex = context.source.length;
  for (let i = 0; i < endTokens.length; i++) {
    const index = context.source.indexOf(endTokens[i], 1);
    if (index !== -1 && endIndex > index) {
      endIndex = index;
    }
  }
  const start = getCursor(context);
  const content = parseTextData(context, endIndex, mode);
  return {
    type: 2,
    content,
    loc: getSelection(context, start)
  };
}
function parseTextData(context, length, mode) {
  const rawText = context.source.slice(0, length);
  advanceBy(context, length);
  if (mode === 2 || mode === 3 || !rawText.includes("&")) {
    return rawText;
  } else {
    return context.options.decodeEntities(
      rawText,
      mode === 4
    );
  }
}
function getCursor(context) {
  const { column, line, offset } = context;
  return { column, line, offset };
}
function getSelection(context, start, end) {
  end = end || getCursor(context);
  return {
    start,
    end,
    source: context.originalSource.slice(start.offset, end.offset)
  };
}
function last(xs) {
  return xs[xs.length - 1];
}
function startsWith(source, searchString) {
  return source.startsWith(searchString);
}
function advanceBy(context, numberOfCharacters) {
  const { source } = context;
  advancePositionWithMutation(context, source, numberOfCharacters);
  context.source = source.slice(numberOfCharacters);
}
function advanceSpaces(context) {
  const match = /^[\t\r\n\f ]+/.exec(context.source);
  if (match) {
    advanceBy(context, match[0].length);
  }
}
function getNewPosition(context, start, numberOfCharacters) {
  return advancePositionWithClone(
    start,
    context.originalSource.slice(start.offset, numberOfCharacters),
    numberOfCharacters
  );
}
function emitError(context, code, offset, loc = getCursor(context)) {
  if (offset) {
    loc.offset += offset;
    loc.column += offset;
  }
  context.options.onError(
    createCompilerError(code, {
      start: loc,
      end: loc,
      source: ""
    })
  );
}
function isEnd(context, mode, ancestors) {
  const s = context.source;
  switch (mode) {
    case 0:
      if (startsWith(s, "</")) {
        for (let i = ancestors.length - 1; i >= 0; --i) {
          if (startsWithEndTagOpen(s, ancestors[i].tag)) {
            return true;
          }
        }
      }
      break;
    case 1:
    case 2: {
      const parent = last(ancestors);
      if (parent && startsWithEndTagOpen(s, parent.tag)) {
        return true;
      }
      break;
    }
    case 3:
      if (startsWith(s, "]]>")) {
        return true;
      }
      break;
  }
  return !s;
}
function startsWithEndTagOpen(source, tag) {
  return startsWith(source, "</") && source.slice(2, 2 + tag.length).toLowerCase() === tag.toLowerCase() && /[\t\r\n\f />]/.test(source[2 + tag.length] || ">");
}
function hoistStatic(root, context) {
  walk(
    root,
    context,
    // Root node is unfortunately non-hoistable due to potential parent
    // fallthrough attributes.
    isSingleElementRoot(root, root.children[0])
  );
}
function isSingleElementRoot(root, child) {
  const { children } = root;
  return children.length === 1 && child.type === 1 && !isSlotOutlet(child);
}
function walk(node, context, doNotHoistNode = false) {
  const { children } = node;
  const originalCount = children.length;
  let hoistedCount = 0;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (child.type === 1 && child.tagType === 0) {
      const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
      if (constantType > 0) {
        if (constantType >= 2) {
          child.codegenNode.patchFlag = -1 + (true ? ` /* HOISTED */` : ``);
          child.codegenNode = context.hoist(child.codegenNode);
          hoistedCount++;
          continue;
        }
      } else {
        const codegenNode = child.codegenNode;
        if (codegenNode.type === 13) {
          const flag = getPatchFlag(codegenNode);
          if ((!flag || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context) >= 2) {
            const props = getNodeProps(child);
            if (props) {
              codegenNode.props = context.hoist(props);
            }
          }
          if (codegenNode.dynamicProps) {
            codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
          }
        }
      }
    }
    if (child.type === 1) {
      const isComponent2 = child.tagType === 1;
      if (isComponent2) {
        context.scopes.vSlot++;
      }
      walk(child, context);
      if (isComponent2) {
        context.scopes.vSlot--;
      }
    } else if (child.type === 11) {
      walk(child, context, child.children.length === 1);
    } else if (child.type === 9) {
      for (let i2 = 0; i2 < child.branches.length; i2++) {
        walk(
          child.branches[i2],
          context,
          child.branches[i2].children.length === 1
        );
      }
    }
  }
  if (hoistedCount && context.transformHoist) {
    context.transformHoist(children, context, node);
  }
  if (hoistedCount && hoistedCount === originalCount && node.type === 1 && node.tagType === 0 && node.codegenNode && node.codegenNode.type === 13 && isArray(node.codegenNode.children)) {
    node.codegenNode.children = context.hoist(
      createArrayExpression(node.codegenNode.children)
    );
  }
}
function getConstantType(node, context) {
  const { constantCache } = context;
  switch (node.type) {
    case 1:
      if (node.tagType !== 0) {
        return 0;
      }
      const cached = constantCache.get(node);
      if (cached !== void 0) {
        return cached;
      }
      const codegenNode = node.codegenNode;
      if (codegenNode.type !== 13) {
        return 0;
      }
      if (codegenNode.isBlock && node.tag !== "svg" && node.tag !== "foreignObject") {
        return 0;
      }
      const flag = getPatchFlag(codegenNode);
      if (!flag) {
        let returnType2 = 3;
        const generatedPropsType = getGeneratedPropsConstantType(node, context);
        if (generatedPropsType === 0) {
          constantCache.set(node, 0);
          return 0;
        }
        if (generatedPropsType < returnType2) {
          returnType2 = generatedPropsType;
        }
        for (let i = 0; i < node.children.length; i++) {
          const childType = getConstantType(node.children[i], context);
          if (childType === 0) {
            constantCache.set(node, 0);
            return 0;
          }
          if (childType < returnType2) {
            returnType2 = childType;
          }
        }
        if (returnType2 > 1) {
          for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            if (p.type === 7 && p.name === "bind" && p.exp) {
              const expType = getConstantType(p.exp, context);
              if (expType === 0) {
                constantCache.set(node, 0);
                return 0;
              }
              if (expType < returnType2) {
                returnType2 = expType;
              }
            }
          }
        }
        if (codegenNode.isBlock) {
          for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            if (p.type === 7) {
              constantCache.set(node, 0);
              return 0;
            }
          }
          context.removeHelper(OPEN_BLOCK);
          context.removeHelper(
            getVNodeBlockHelper(context.inSSR, codegenNode.isComponent)
          );
          codegenNode.isBlock = false;
          context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
        }
        constantCache.set(node, returnType2);
        return returnType2;
      } else {
        constantCache.set(node, 0);
        return 0;
      }
    case 2:
    case 3:
      return 3;
    case 9:
    case 11:
    case 10:
      return 0;
    case 5:
    case 12:
      return getConstantType(node.content, context);
    case 4:
      return node.constType;
    case 8:
      let returnType = 3;
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if (isString(child) || isSymbol(child)) {
          continue;
        }
        const childType = getConstantType(child, context);
        if (childType === 0) {
          return 0;
        } else if (childType < returnType) {
          returnType = childType;
        }
      }
      return returnType;
    default:
      if (true)
        ;
      return 0;
  }
}
function getConstantTypeOfHelperCall(value, context) {
  if (value.type === 14 && !isString(value.callee) && allowHoistedHelperSet.has(value.callee)) {
    const arg = value.arguments[0];
    if (arg.type === 4) {
      return getConstantType(arg, context);
    } else if (arg.type === 14) {
      return getConstantTypeOfHelperCall(arg, context);
    }
  }
  return 0;
}
function getGeneratedPropsConstantType(node, context) {
  let returnType = 3;
  const props = getNodeProps(node);
  if (props && props.type === 15) {
    const { properties } = props;
    for (let i = 0; i < properties.length; i++) {
      const { key, value } = properties[i];
      const keyType = getConstantType(key, context);
      if (keyType === 0) {
        return keyType;
      }
      if (keyType < returnType) {
        returnType = keyType;
      }
      let valueType;
      if (value.type === 4) {
        valueType = getConstantType(value, context);
      } else if (value.type === 14) {
        valueType = getConstantTypeOfHelperCall(value, context);
      } else {
        valueType = 0;
      }
      if (valueType === 0) {
        return valueType;
      }
      if (valueType < returnType) {
        returnType = valueType;
      }
    }
  }
  return returnType;
}
function getNodeProps(node) {
  const codegenNode = node.codegenNode;
  if (codegenNode.type === 13) {
    return codegenNode.props;
  }
}
function getPatchFlag(node) {
  const flag = node.patchFlag;
  return flag ? parseInt(flag, 10) : void 0;
}
function createTransformContext(root, {
  filename = "",
  prefixIdentifiers = false,
  hoistStatic: hoistStatic2 = false,
  cacheHandlers = false,
  nodeTransforms = [],
  directiveTransforms = {},
  transformHoist = null,
  isBuiltInComponent = NOOP,
  isCustomElement = NOOP,
  expressionPlugins = [],
  scopeId = null,
  slotted = true,
  ssr = false,
  inSSR = false,
  ssrCssVars = ``,
  bindingMetadata = EMPTY_OBJ,
  inline = false,
  isTS = false,
  onError = defaultOnError,
  onWarn = defaultOnWarn,
  compatConfig
}) {
  const nameMatch = filename.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
  const context = {
    // options
    selfName: nameMatch && capitalize(camelize(nameMatch[1])),
    prefixIdentifiers,
    hoistStatic: hoistStatic2,
    cacheHandlers,
    nodeTransforms,
    directiveTransforms,
    transformHoist,
    isBuiltInComponent,
    isCustomElement,
    expressionPlugins,
    scopeId,
    slotted,
    ssr,
    inSSR,
    ssrCssVars,
    bindingMetadata,
    inline,
    isTS,
    onError,
    onWarn,
    compatConfig,
    // state
    root,
    helpers: /* @__PURE__ */ new Map(),
    components: /* @__PURE__ */ new Set(),
    directives: /* @__PURE__ */ new Set(),
    hoists: [],
    imports: [],
    constantCache: /* @__PURE__ */ new Map(),
    temps: 0,
    cached: 0,
    identifiers: /* @__PURE__ */ Object.create(null),
    scopes: {
      vFor: 0,
      vSlot: 0,
      vPre: 0,
      vOnce: 0
    },
    parent: null,
    currentNode: root,
    childIndex: 0,
    inVOnce: false,
    // methods
    helper(name) {
      const count = context.helpers.get(name) || 0;
      context.helpers.set(name, count + 1);
      return name;
    },
    removeHelper(name) {
      const count = context.helpers.get(name);
      if (count) {
        const currentCount = count - 1;
        if (!currentCount) {
          context.helpers.delete(name);
        } else {
          context.helpers.set(name, currentCount);
        }
      }
    },
    helperString(name) {
      return `_${helperNameMap[context.helper(name)]}`;
    },
    replaceNode(node) {
      if (true) {
        if (!context.currentNode) {
          throw new Error(`Node being replaced is already removed.`);
        }
        if (!context.parent) {
          throw new Error(`Cannot replace root node.`);
        }
      }
      context.parent.children[context.childIndex] = context.currentNode = node;
    },
    removeNode(node) {
      if (!context.parent) {
        throw new Error(`Cannot remove root node.`);
      }
      const list = context.parent.children;
      const removalIndex = node ? list.indexOf(node) : context.currentNode ? context.childIndex : -1;
      if (removalIndex < 0) {
        throw new Error(`node being removed is not a child of current parent`);
      }
      if (!node || node === context.currentNode) {
        context.currentNode = null;
        context.onNodeRemoved();
      } else {
        if (context.childIndex > removalIndex) {
          context.childIndex--;
          context.onNodeRemoved();
        }
      }
      context.parent.children.splice(removalIndex, 1);
    },
    onNodeRemoved: () => {
    },
    addIdentifiers(exp) {
    },
    removeIdentifiers(exp) {
    },
    hoist(exp) {
      if (isString(exp))
        exp = createSimpleExpression(exp);
      context.hoists.push(exp);
      const identifier = createSimpleExpression(
        `_hoisted_${context.hoists.length}`,
        false,
        exp.loc,
        2
      );
      identifier.hoisted = exp;
      return identifier;
    },
    cache(exp, isVNode = false) {
      return createCacheExpression(context.cached++, exp, isVNode);
    }
  };
  {
    context.filters = /* @__PURE__ */ new Set();
  }
  return context;
}
function transform(root, options) {
  const context = createTransformContext(root, options);
  traverseNode(root, context);
  if (options.hoistStatic) {
    hoistStatic(root, context);
  }
  if (!options.ssr) {
    createRootCodegen(root, context);
  }
  root.helpers = /* @__PURE__ */ new Set([...context.helpers.keys()]);
  root.components = [...context.components];
  root.directives = [...context.directives];
  root.imports = context.imports;
  root.hoists = context.hoists;
  root.temps = context.temps;
  root.cached = context.cached;
  {
    root.filters = [...context.filters];
  }
}
function createRootCodegen(root, context) {
  const { helper } = context;
  const { children } = root;
  if (children.length === 1) {
    const child = children[0];
    if (isSingleElementRoot(root, child) && child.codegenNode) {
      const codegenNode = child.codegenNode;
      if (codegenNode.type === 13) {
        convertToBlock(codegenNode, context);
      }
      root.codegenNode = codegenNode;
    } else {
      root.codegenNode = child;
    }
  } else if (children.length > 1) {
    let patchFlag = 64;
    let patchFlagText = PatchFlagNames[64];
    if (children.filter((c) => c.type !== 3).length === 1) {
      patchFlag |= 2048;
      patchFlagText += `, ${PatchFlagNames[2048]}`;
    }
    root.codegenNode = createVNodeCall(
      context,
      helper(FRAGMENT),
      void 0,
      root.children,
      patchFlag + (true ? ` /* ${patchFlagText} */` : ``),
      void 0,
      void 0,
      true,
      void 0,
      false
      /* isComponent */
    );
  } else
    ;
}
function traverseChildren(parent, context) {
  let i = 0;
  const nodeRemoved = () => {
    i--;
  };
  for (; i < parent.children.length; i++) {
    const child = parent.children[i];
    if (isString(child))
      continue;
    context.parent = parent;
    context.childIndex = i;
    context.onNodeRemoved = nodeRemoved;
    traverseNode(child, context);
  }
}
function traverseNode(node, context) {
  context.currentNode = node;
  const { nodeTransforms } = context;
  const exitFns = [];
  for (let i2 = 0; i2 < nodeTransforms.length; i2++) {
    const onExit = nodeTransforms[i2](node, context);
    if (onExit) {
      if (isArray(onExit)) {
        exitFns.push(...onExit);
      } else {
        exitFns.push(onExit);
      }
    }
    if (!context.currentNode) {
      return;
    } else {
      node = context.currentNode;
    }
  }
  switch (node.type) {
    case 3:
      if (!context.ssr) {
        context.helper(CREATE_COMMENT);
      }
      break;
    case 5:
      if (!context.ssr) {
        context.helper(TO_DISPLAY_STRING);
      }
      break;
    case 9:
      for (let i2 = 0; i2 < node.branches.length; i2++) {
        traverseNode(node.branches[i2], context);
      }
      break;
    case 10:
    case 11:
    case 1:
    case 0:
      traverseChildren(node, context);
      break;
  }
  context.currentNode = node;
  let i = exitFns.length;
  while (i--) {
    exitFns[i]();
  }
}
function createStructuralDirectiveTransform(name, fn) {
  const matches = isString(name) ? (n) => n === name : (n) => name.test(n);
  return (node, context) => {
    if (node.type === 1) {
      const { props } = node;
      if (node.tagType === 3 && props.some(isVSlot)) {
        return;
      }
      const exitFns = [];
      for (let i = 0; i < props.length; i++) {
        const prop = props[i];
        if (prop.type === 7 && matches(prop.name)) {
          props.splice(i, 1);
          i--;
          const onExit = fn(node, prop, context);
          if (onExit)
            exitFns.push(onExit);
        }
      }
      return exitFns;
    }
  };
}
function createCodegenContext(ast, {
  mode = "function",
  prefixIdentifiers = mode === "module",
  sourceMap = false,
  filename = `template.vue.html`,
  scopeId = null,
  optimizeImports = false,
  runtimeGlobalName = `Vue`,
  runtimeModuleName = `vue`,
  ssrRuntimeModuleName = "vue/server-renderer",
  ssr = false,
  isTS = false,
  inSSR = false
}) {
  const context = {
    mode,
    prefixIdentifiers,
    sourceMap,
    filename,
    scopeId,
    optimizeImports,
    runtimeGlobalName,
    runtimeModuleName,
    ssrRuntimeModuleName,
    ssr,
    isTS,
    inSSR,
    source: ast.loc.source,
    code: ``,
    column: 1,
    line: 1,
    offset: 0,
    indentLevel: 0,
    pure: false,
    map: void 0,
    helper(key) {
      return `_${helperNameMap[key]}`;
    },
    push(code, node) {
      context.code += code;
    },
    indent() {
      newline(++context.indentLevel);
    },
    deindent(withoutNewLine = false) {
      if (withoutNewLine) {
        --context.indentLevel;
      } else {
        newline(--context.indentLevel);
      }
    },
    newline() {
      newline(context.indentLevel);
    }
  };
  function newline(n) {
    context.push("\n" + `  `.repeat(n));
  }
  return context;
}
function generate(ast, options = {}) {
  const context = createCodegenContext(ast, options);
  if (options.onContextCreated)
    options.onContextCreated(context);
  const {
    mode,
    push,
    prefixIdentifiers,
    indent,
    deindent,
    newline,
    scopeId,
    ssr
  } = context;
  const helpers = Array.from(ast.helpers);
  const hasHelpers = helpers.length > 0;
  const useWithBlock = !prefixIdentifiers && mode !== "module";
  const isSetupInlined = false;
  const preambleContext = isSetupInlined ? createCodegenContext(ast, options) : context;
  {
    genFunctionPreamble(ast, preambleContext);
  }
  const functionName = ssr ? `ssrRender` : `render`;
  const args = ssr ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
  const signature = args.join(", ");
  {
    push(`function ${functionName}(${signature}) {`);
  }
  indent();
  if (useWithBlock) {
    push(`with (_ctx) {`);
    indent();
    if (hasHelpers) {
      push(`const { ${helpers.map(aliasHelper).join(", ")} } = _Vue`);
      push(`
`);
      newline();
    }
  }
  if (ast.components.length) {
    genAssets(ast.components, "component", context);
    if (ast.directives.length || ast.temps > 0) {
      newline();
    }
  }
  if (ast.directives.length) {
    genAssets(ast.directives, "directive", context);
    if (ast.temps > 0) {
      newline();
    }
  }
  if (ast.filters && ast.filters.length) {
    newline();
    genAssets(ast.filters, "filter", context);
    newline();
  }
  if (ast.temps > 0) {
    push(`let `);
    for (let i = 0; i < ast.temps; i++) {
      push(`${i > 0 ? `, ` : ``}_temp${i}`);
    }
  }
  if (ast.components.length || ast.directives.length || ast.temps) {
    push(`
`);
    newline();
  }
  if (!ssr) {
    push(`return `);
  }
  if (ast.codegenNode) {
    genNode(ast.codegenNode, context);
  } else {
    push(`null`);
  }
  if (useWithBlock) {
    deindent();
    push(`}`);
  }
  deindent();
  push(`}`);
  return {
    ast,
    code: context.code,
    preamble: isSetupInlined ? preambleContext.code : ``,
    // SourceMapGenerator does have toJSON() method but it's not in the types
    map: context.map ? context.map.toJSON() : void 0
  };
}
function genFunctionPreamble(ast, context) {
  const {
    ssr,
    prefixIdentifiers,
    push,
    newline,
    runtimeModuleName,
    runtimeGlobalName,
    ssrRuntimeModuleName
  } = context;
  const VueBinding = runtimeGlobalName;
  const helpers = Array.from(ast.helpers);
  if (helpers.length > 0) {
    {
      push(`const _Vue = ${VueBinding}
`);
      if (ast.hoists.length) {
        const staticHelpers = [
          CREATE_VNODE,
          CREATE_ELEMENT_VNODE,
          CREATE_COMMENT,
          CREATE_TEXT,
          CREATE_STATIC
        ].filter((helper) => helpers.includes(helper)).map(aliasHelper).join(", ");
        push(`const { ${staticHelpers} } = _Vue
`);
      }
    }
  }
  genHoists(ast.hoists, context);
  newline();
  push(`return `);
}
function genAssets(assets, type, { helper, push, newline, isTS }) {
  const resolver = helper(
    type === "filter" ? RESOLVE_FILTER : type === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE
  );
  for (let i = 0; i < assets.length; i++) {
    let id = assets[i];
    const maybeSelfReference = id.endsWith("__self");
    if (maybeSelfReference) {
      id = id.slice(0, -6);
    }
    push(
      `const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`
    );
    if (i < assets.length - 1) {
      newline();
    }
  }
}
function genHoists(hoists, context) {
  if (!hoists.length) {
    return;
  }
  context.pure = true;
  const { push, newline, helper, scopeId, mode } = context;
  newline();
  for (let i = 0; i < hoists.length; i++) {
    const exp = hoists[i];
    if (exp) {
      push(
        `const _hoisted_${i + 1} = ${``}`
      );
      genNode(exp, context);
      newline();
    }
  }
  context.pure = false;
}
function isText(n) {
  return isString(n) || n.type === 4 || n.type === 2 || n.type === 5 || n.type === 8;
}
function genNodeListAsArray(nodes, context) {
  const multilines = nodes.length > 3 || nodes.some((n) => isArray(n) || !isText(n));
  context.push(`[`);
  multilines && context.indent();
  genNodeList(nodes, context, multilines);
  multilines && context.deindent();
  context.push(`]`);
}
function genNodeList(nodes, context, multilines = false, comma = true) {
  const { push, newline } = context;
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (isString(node)) {
      push(node);
    } else if (isArray(node)) {
      genNodeListAsArray(node, context);
    } else {
      genNode(node, context);
    }
    if (i < nodes.length - 1) {
      if (multilines) {
        comma && push(",");
        newline();
      } else {
        comma && push(", ");
      }
    }
  }
}
function genNode(node, context) {
  if (isString(node)) {
    context.push(node);
    return;
  }
  if (isSymbol(node)) {
    context.push(context.helper(node));
    return;
  }
  switch (node.type) {
    case 1:
    case 9:
    case 11:
      assert(
        node.codegenNode != null,
        `Codegen node is missing for element/if/for node. Apply appropriate transforms first.`
      );
      genNode(node.codegenNode, context);
      break;
    case 2:
      genText(node, context);
      break;
    case 4:
      genExpression(node, context);
      break;
    case 5:
      genInterpolation(node, context);
      break;
    case 12:
      genNode(node.codegenNode, context);
      break;
    case 8:
      genCompoundExpression(node, context);
      break;
    case 3:
      genComment(node, context);
      break;
    case 13:
      genVNodeCall(node, context);
      break;
    case 14:
      genCallExpression(node, context);
      break;
    case 15:
      genObjectExpression(node, context);
      break;
    case 17:
      genArrayExpression(node, context);
      break;
    case 18:
      genFunctionExpression(node, context);
      break;
    case 19:
      genConditionalExpression(node, context);
      break;
    case 20:
      genCacheExpression(node, context);
      break;
    case 21:
      genNodeList(node.body, context, true, false);
      break;
    case 22:
      break;
    case 23:
      break;
    case 24:
      break;
    case 25:
      break;
    case 26:
      break;
    case 10:
      break;
    default:
      if (true) {
        assert(false, `unhandled codegen node type: ${node.type}`);
        const exhaustiveCheck = node;
        return exhaustiveCheck;
      }
  }
}
function genText(node, context) {
  context.push(JSON.stringify(node.content), node);
}
function genExpression(node, context) {
  const { content, isStatic } = node;
  context.push(isStatic ? JSON.stringify(content) : content, node);
}
function genInterpolation(node, context) {
  const { push, helper, pure } = context;
  if (pure)
    push(PURE_ANNOTATION);
  push(`${helper(TO_DISPLAY_STRING)}(`);
  genNode(node.content, context);
  push(`)`);
}
function genCompoundExpression(node, context) {
  for (let i = 0; i < node.children.length; i++) {
    const child = node.children[i];
    if (isString(child)) {
      context.push(child);
    } else {
      genNode(child, context);
    }
  }
}
function genExpressionAsPropertyKey(node, context) {
  const { push } = context;
  if (node.type === 8) {
    push(`[`);
    genCompoundExpression(node, context);
    push(`]`);
  } else if (node.isStatic) {
    const text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);
    push(text, node);
  } else {
    push(`[${node.content}]`, node);
  }
}
function genComment(node, context) {
  const { push, helper, pure } = context;
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node);
}
function genVNodeCall(node, context) {
  const { push, helper, pure } = context;
  const {
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent: isComponent2
  } = node;
  if (directives) {
    push(helper(WITH_DIRECTIVES) + `(`);
  }
  if (isBlock) {
    push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
  }
  if (pure) {
    push(PURE_ANNOTATION);
  }
  const callHelper = isBlock ? getVNodeBlockHelper(context.inSSR, isComponent2) : getVNodeHelper(context.inSSR, isComponent2);
  push(helper(callHelper) + `(`, node);
  genNodeList(
    genNullableArgs([tag, props, children, patchFlag, dynamicProps]),
    context
  );
  push(`)`);
  if (isBlock) {
    push(`)`);
  }
  if (directives) {
    push(`, `);
    genNode(directives, context);
    push(`)`);
  }
}
function genNullableArgs(args) {
  let i = args.length;
  while (i--) {
    if (args[i] != null)
      break;
  }
  return args.slice(0, i + 1).map((arg) => arg || `null`);
}
function genCallExpression(node, context) {
  const { push, helper, pure } = context;
  const callee = isString(node.callee) ? node.callee : helper(node.callee);
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(callee + `(`, node);
  genNodeList(node.arguments, context);
  push(`)`);
}
function genObjectExpression(node, context) {
  const { push, indent, deindent, newline } = context;
  const { properties } = node;
  if (!properties.length) {
    push(`{}`, node);
    return;
  }
  const multilines = properties.length > 1 || properties.some((p) => p.value.type !== 4);
  push(multilines ? `{` : `{ `);
  multilines && indent();
  for (let i = 0; i < properties.length; i++) {
    const { key, value } = properties[i];
    genExpressionAsPropertyKey(key, context);
    push(`: `);
    genNode(value, context);
    if (i < properties.length - 1) {
      push(`,`);
      newline();
    }
  }
  multilines && deindent();
  push(multilines ? `}` : ` }`);
}
function genArrayExpression(node, context) {
  genNodeListAsArray(node.elements, context);
}
function genFunctionExpression(node, context) {
  const { push, indent, deindent } = context;
  const { params, returns, body, newline, isSlot } = node;
  if (isSlot) {
    push(`_${helperNameMap[WITH_CTX]}(`);
  }
  push(`(`, node);
  if (isArray(params)) {
    genNodeList(params, context);
  } else if (params) {
    genNode(params, context);
  }
  push(`) => `);
  if (newline || body) {
    push(`{`);
    indent();
  }
  if (returns) {
    if (newline) {
      push(`return `);
    }
    if (isArray(returns)) {
      genNodeListAsArray(returns, context);
    } else {
      genNode(returns, context);
    }
  } else if (body) {
    genNode(body, context);
  }
  if (newline || body) {
    deindent();
    push(`}`);
  }
  if (isSlot) {
    if (node.isNonScopedSlot) {
      push(`, undefined, true`);
    }
    push(`)`);
  }
}
function genConditionalExpression(node, context) {
  const { test, consequent, alternate, newline: needNewline } = node;
  const { push, indent, deindent, newline } = context;
  if (test.type === 4) {
    const needsParens = !isSimpleIdentifier(test.content);
    needsParens && push(`(`);
    genExpression(test, context);
    needsParens && push(`)`);
  } else {
    push(`(`);
    genNode(test, context);
    push(`)`);
  }
  needNewline && indent();
  context.indentLevel++;
  needNewline || push(` `);
  push(`? `);
  genNode(consequent, context);
  context.indentLevel--;
  needNewline && newline();
  needNewline || push(` `);
  push(`: `);
  const isNested = alternate.type === 19;
  if (!isNested) {
    context.indentLevel++;
  }
  genNode(alternate, context);
  if (!isNested) {
    context.indentLevel--;
  }
  needNewline && deindent(
    true
    /* without newline */
  );
}
function genCacheExpression(node, context) {
  const { push, helper, indent, deindent, newline } = context;
  push(`_cache[${node.index}] || (`);
  if (node.isVNode) {
    indent();
    push(`${helper(SET_BLOCK_TRACKING)}(-1),`);
    newline();
  }
  push(`_cache[${node.index}] = `);
  genNode(node.value, context);
  if (node.isVNode) {
    push(`,`);
    newline();
    push(`${helper(SET_BLOCK_TRACKING)}(1),`);
    newline();
    push(`_cache[${node.index}]`);
    deindent();
  }
  push(`)`);
}
function walkIdentifiers(root, onIdentifier, includeAll = false, parentStack = [], knownIds = /* @__PURE__ */ Object.create(null)) {
  {
    return;
  }
}
function isReferencedIdentifier(id, parent, parentStack) {
  {
    return false;
  }
}
function isInDestructureAssignment(parent, parentStack) {
  if (parent && (parent.type === "ObjectProperty" || parent.type === "ArrayPattern")) {
    let i = parentStack.length;
    while (i--) {
      const p = parentStack[i];
      if (p.type === "AssignmentExpression") {
        return true;
      } else if (p.type !== "ObjectProperty" && !p.type.endsWith("Pattern")) {
        break;
      }
    }
  }
  return false;
}
function walkFunctionParams(node, onIdent) {
  for (const p of node.params) {
    for (const id of extractIdentifiers(p)) {
      onIdent(id);
    }
  }
}
function walkBlockDeclarations(block, onIdent) {
  for (const stmt of block.body) {
    if (stmt.type === "VariableDeclaration") {
      if (stmt.declare)
        continue;
      for (const decl of stmt.declarations) {
        for (const id of extractIdentifiers(decl.id)) {
          onIdent(id);
        }
      }
    } else if (stmt.type === "FunctionDeclaration" || stmt.type === "ClassDeclaration") {
      if (stmt.declare || !stmt.id)
        continue;
      onIdent(stmt.id);
    }
  }
}
function extractIdentifiers(param, nodes = []) {
  switch (param.type) {
    case "Identifier":
      nodes.push(param);
      break;
    case "MemberExpression":
      let object = param;
      while (object.type === "MemberExpression") {
        object = object.object;
      }
      nodes.push(object);
      break;
    case "ObjectPattern":
      for (const prop of param.properties) {
        if (prop.type === "RestElement") {
          extractIdentifiers(prop.argument, nodes);
        } else {
          extractIdentifiers(prop.value, nodes);
        }
      }
      break;
    case "ArrayPattern":
      param.elements.forEach((element) => {
        if (element)
          extractIdentifiers(element, nodes);
      });
      break;
    case "RestElement":
      extractIdentifiers(param.argument, nodes);
      break;
    case "AssignmentPattern":
      extractIdentifiers(param.left, nodes);
      break;
  }
  return nodes;
}
function validateBrowserExpression(node, context, asParams = false, asRawStatements = false) {
  const exp = node.content;
  if (!exp.trim()) {
    return;
  }
  try {
    new Function(
      asRawStatements ? ` ${exp} ` : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`
    );
  } catch (e) {
    let message = e.message;
    const keywordMatch = exp.replace(stripStringRE, "").match(prohibitedKeywordRE);
    if (keywordMatch) {
      message = `avoid using JavaScript keyword as property name: "${keywordMatch[0]}"`;
    }
    context.onError(
      createCompilerError(
        45,
        node.loc,
        void 0,
        message
      )
    );
  }
}
function processExpression(node, context, asParams = false, asRawStatements = false, localVars = Object.create(context.identifiers)) {
  {
    if (true) {
      validateBrowserExpression(node, context, asParams, asRawStatements);
    }
    return node;
  }
}
function stringifyExpression(exp) {
  if (isString(exp)) {
    return exp;
  } else if (exp.type === 4) {
    return exp.content;
  } else {
    return exp.children.map(stringifyExpression).join("");
  }
}
function processIf(node, dir, context, processCodegen) {
  if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
    const loc = dir.exp ? dir.exp.loc : node.loc;
    context.onError(
      createCompilerError(28, dir.loc)
    );
    dir.exp = createSimpleExpression(`true`, false, loc);
  }
  if (dir.exp) {
    validateBrowserExpression(dir.exp, context);
  }
  if (dir.name === "if") {
    const branch = createIfBranch(node, dir);
    const ifNode = {
      type: 9,
      loc: node.loc,
      branches: [branch]
    };
    context.replaceNode(ifNode);
    if (processCodegen) {
      return processCodegen(ifNode, branch, true);
    }
  } else {
    const siblings = context.parent.children;
    const comments = [];
    let i = siblings.indexOf(node);
    while (i-- >= -1) {
      const sibling = siblings[i];
      if (sibling && sibling.type === 3) {
        context.removeNode(sibling);
        comments.unshift(sibling);
        continue;
      }
      if (sibling && sibling.type === 2 && !sibling.content.trim().length) {
        context.removeNode(sibling);
        continue;
      }
      if (sibling && sibling.type === 9) {
        if (dir.name === "else-if" && sibling.branches[sibling.branches.length - 1].condition === void 0) {
          context.onError(
            createCompilerError(30, node.loc)
          );
        }
        context.removeNode();
        const branch = createIfBranch(node, dir);
        if (comments.length && // #3619 ignore comments if the v-if is direct child of <transition>
        !(context.parent && context.parent.type === 1 && isBuiltInType(context.parent.tag, "transition"))) {
          branch.children = [...comments, ...branch.children];
        }
        if (true) {
          const key = branch.userKey;
          if (key) {
            sibling.branches.forEach(({ userKey }) => {
              if (isSameKey(userKey, key)) {
                context.onError(
                  createCompilerError(
                    29,
                    branch.userKey.loc
                  )
                );
              }
            });
          }
        }
        sibling.branches.push(branch);
        const onExit = processCodegen && processCodegen(sibling, branch, false);
        traverseNode(branch, context);
        if (onExit)
          onExit();
        context.currentNode = null;
      } else {
        context.onError(
          createCompilerError(30, node.loc)
        );
      }
      break;
    }
  }
}
function createIfBranch(node, dir) {
  const isTemplateIf = node.tagType === 3;
  return {
    type: 10,
    loc: node.loc,
    condition: dir.name === "else" ? void 0 : dir.exp,
    children: isTemplateIf && !findDir(node, "for") ? node.children : [node],
    userKey: findProp(node, `key`),
    isTemplateIf
  };
}
function createCodegenNodeForBranch(branch, keyIndex, context) {
  if (branch.condition) {
    return createConditionalExpression(
      branch.condition,
      createChildrenCodegenNode(branch, keyIndex, context),
      // make sure to pass in asBlock: true so that the comment node call
      // closes the current block.
      createCallExpression(context.helper(CREATE_COMMENT), [
        true ? '"v-if"' : '""',
        "true"
      ])
    );
  } else {
    return createChildrenCodegenNode(branch, keyIndex, context);
  }
}
function createChildrenCodegenNode(branch, keyIndex, context) {
  const { helper } = context;
  const keyProperty = createObjectProperty(
    `key`,
    createSimpleExpression(
      `${keyIndex}`,
      false,
      locStub,
      2
    )
  );
  const { children } = branch;
  const firstChild = children[0];
  const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;
  if (needFragmentWrapper) {
    if (children.length === 1 && firstChild.type === 11) {
      const vnodeCall = firstChild.codegenNode;
      injectProp(vnodeCall, keyProperty, context);
      return vnodeCall;
    } else {
      let patchFlag = 64;
      let patchFlagText = PatchFlagNames[64];
      if (!branch.isTemplateIf && children.filter((c) => c.type !== 3).length === 1) {
        patchFlag |= 2048;
        patchFlagText += `, ${PatchFlagNames[2048]}`;
      }
      return createVNodeCall(
        context,
        helper(FRAGMENT),
        createObjectExpression([keyProperty]),
        children,
        patchFlag + (true ? ` /* ${patchFlagText} */` : ``),
        void 0,
        void 0,
        true,
        false,
        false,
        branch.loc
      );
    }
  } else {
    const ret = firstChild.codegenNode;
    const vnodeCall = getMemoedVNodeCall(ret);
    if (vnodeCall.type === 13) {
      convertToBlock(vnodeCall, context);
    }
    injectProp(vnodeCall, keyProperty, context);
    return ret;
  }
}
function isSameKey(a, b) {
  if (!a || a.type !== b.type) {
    return false;
  }
  if (a.type === 6) {
    if (a.value.content !== b.value.content) {
      return false;
    }
  } else {
    const exp = a.exp;
    const branchExp = b.exp;
    if (exp.type !== branchExp.type) {
      return false;
    }
    if (exp.type !== 4 || exp.isStatic !== branchExp.isStatic || exp.content !== branchExp.content) {
      return false;
    }
  }
  return true;
}
function getParentCondition(node) {
  while (true) {
    if (node.type === 19) {
      if (node.alternate.type === 19) {
        node = node.alternate;
      } else {
        return node;
      }
    } else if (node.type === 20) {
      node = node.value;
    }
  }
}
function processFor(node, dir, context, processCodegen) {
  if (!dir.exp) {
    context.onError(
      createCompilerError(31, dir.loc)
    );
    return;
  }
  const parseResult = parseForExpression(
    // can only be simple expression because vFor transform is applied
    // before expression transform.
    dir.exp,
    context
  );
  if (!parseResult) {
    context.onError(
      createCompilerError(32, dir.loc)
    );
    return;
  }
  const { addIdentifiers, removeIdentifiers, scopes } = context;
  const { source, value, key, index } = parseResult;
  const forNode = {
    type: 11,
    loc: dir.loc,
    source,
    valueAlias: value,
    keyAlias: key,
    objectIndexAlias: index,
    parseResult,
    children: isTemplateNode(node) ? node.children : [node]
  };
  context.replaceNode(forNode);
  scopes.vFor++;
  const onExit = processCodegen && processCodegen(forNode);
  return () => {
    scopes.vFor--;
    if (onExit)
      onExit();
  };
}
function parseForExpression(input, context) {
  const loc = input.loc;
  const exp = input.content;
  const inMatch = exp.match(forAliasRE);
  if (!inMatch)
    return;
  const [, LHS, RHS] = inMatch;
  const result = {
    source: createAliasExpression(
      loc,
      RHS.trim(),
      exp.indexOf(RHS, LHS.length)
    ),
    value: void 0,
    key: void 0,
    index: void 0
  };
  if (true) {
    validateBrowserExpression(result.source, context);
  }
  let valueContent = LHS.trim().replace(stripParensRE, "").trim();
  const trimmedOffset = LHS.indexOf(valueContent);
  const iteratorMatch = valueContent.match(forIteratorRE);
  if (iteratorMatch) {
    valueContent = valueContent.replace(forIteratorRE, "").trim();
    const keyContent = iteratorMatch[1].trim();
    let keyOffset;
    if (keyContent) {
      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
      result.key = createAliasExpression(loc, keyContent, keyOffset);
      if (true) {
        validateBrowserExpression(
          result.key,
          context,
          true
        );
      }
    }
    if (iteratorMatch[2]) {
      const indexContent = iteratorMatch[2].trim();
      if (indexContent) {
        result.index = createAliasExpression(
          loc,
          indexContent,
          exp.indexOf(
            indexContent,
            result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length
          )
        );
        if (true) {
          validateBrowserExpression(
            result.index,
            context,
            true
          );
        }
      }
    }
  }
  if (valueContent) {
    result.value = createAliasExpression(loc, valueContent, trimmedOffset);
    if (true) {
      validateBrowserExpression(
        result.value,
        context,
        true
      );
    }
  }
  return result;
}
function createAliasExpression(range, content, offset) {
  return createSimpleExpression(
    content,
    false,
    getInnerRange(range, offset, content.length)
  );
}
function createForLoopParams({ value, key, index }, memoArgs = []) {
  return createParamsList([value, key, index, ...memoArgs]);
}
function createParamsList(args) {
  let i = args.length;
  while (i--) {
    if (args[i])
      break;
  }
  return args.slice(0, i + 1).map((arg, i2) => arg || createSimpleExpression(`_`.repeat(i2 + 1), false));
}
function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
  context.helper(WITH_CTX);
  const { children, loc } = node;
  const slotsProperties = [];
  const dynamicSlots = [];
  let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
  const onComponentSlot = findDir(node, "slot", true);
  if (onComponentSlot) {
    const { arg, exp } = onComponentSlot;
    if (arg && !isStaticExp(arg)) {
      hasDynamicSlots = true;
    }
    slotsProperties.push(
      createObjectProperty(
        arg || createSimpleExpression("default", true),
        buildSlotFn(exp, children, loc)
      )
    );
  }
  let hasTemplateSlots = false;
  let hasNamedDefaultSlot = false;
  const implicitDefaultChildren = [];
  const seenSlotNames = /* @__PURE__ */ new Set();
  let conditionalBranchIndex = 0;
  for (let i = 0; i < children.length; i++) {
    const slotElement = children[i];
    let slotDir;
    if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, "slot", true))) {
      if (slotElement.type !== 3) {
        implicitDefaultChildren.push(slotElement);
      }
      continue;
    }
    if (onComponentSlot) {
      context.onError(
        createCompilerError(37, slotDir.loc)
      );
      break;
    }
    hasTemplateSlots = true;
    const { children: slotChildren, loc: slotLoc } = slotElement;
    const {
      arg: slotName = createSimpleExpression(`default`, true),
      exp: slotProps,
      loc: dirLoc
    } = slotDir;
    let staticSlotName;
    if (isStaticExp(slotName)) {
      staticSlotName = slotName ? slotName.content : `default`;
    } else {
      hasDynamicSlots = true;
    }
    const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);
    let vIf;
    let vElse;
    let vFor;
    if (vIf = findDir(slotElement, "if")) {
      hasDynamicSlots = true;
      dynamicSlots.push(
        createConditionalExpression(
          vIf.exp,
          buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++),
          defaultFallback
        )
      );
    } else if (vElse = findDir(
      slotElement,
      /^else(-if)?$/,
      true
      /* allowEmpty */
    )) {
      let j = i;
      let prev;
      while (j--) {
        prev = children[j];
        if (prev.type !== 3) {
          break;
        }
      }
      if (prev && isTemplateNode(prev) && findDir(prev, "if")) {
        children.splice(i, 1);
        i--;
        let conditional = dynamicSlots[dynamicSlots.length - 1];
        while (conditional.alternate.type === 19) {
          conditional = conditional.alternate;
        }
        conditional.alternate = vElse.exp ? createConditionalExpression(
          vElse.exp,
          buildDynamicSlot(
            slotName,
            slotFunction,
            conditionalBranchIndex++
          ),
          defaultFallback
        ) : buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++);
      } else {
        context.onError(
          createCompilerError(30, vElse.loc)
        );
      }
    } else if (vFor = findDir(slotElement, "for")) {
      hasDynamicSlots = true;
      const parseResult = vFor.parseResult || parseForExpression(vFor.exp, context);
      if (parseResult) {
        dynamicSlots.push(
          createCallExpression(context.helper(RENDER_LIST), [
            parseResult.source,
            createFunctionExpression(
              createForLoopParams(parseResult),
              buildDynamicSlot(slotName, slotFunction),
              true
              /* force newline */
            )
          ])
        );
      } else {
        context.onError(
          createCompilerError(32, vFor.loc)
        );
      }
    } else {
      if (staticSlotName) {
        if (seenSlotNames.has(staticSlotName)) {
          context.onError(
            createCompilerError(
              38,
              dirLoc
            )
          );
          continue;
        }
        seenSlotNames.add(staticSlotName);
        if (staticSlotName === "default") {
          hasNamedDefaultSlot = true;
        }
      }
      slotsProperties.push(createObjectProperty(slotName, slotFunction));
    }
  }
  if (!onComponentSlot) {
    const buildDefaultSlotProperty = (props, children2) => {
      const fn = buildSlotFn(props, children2, loc);
      if (context.compatConfig) {
        fn.isNonScopedSlot = true;
      }
      return createObjectProperty(`default`, fn);
    };
    if (!hasTemplateSlots) {
      slotsProperties.push(buildDefaultSlotProperty(void 0, children));
    } else if (implicitDefaultChildren.length && // #3766
    // with whitespace: 'preserve', whitespaces between slots will end up in
    // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
    implicitDefaultChildren.some((node2) => isNonWhitespaceContent(node2))) {
      if (hasNamedDefaultSlot) {
        context.onError(
          createCompilerError(
            39,
            implicitDefaultChildren[0].loc
          )
        );
      } else {
        slotsProperties.push(
          buildDefaultSlotProperty(void 0, implicitDefaultChildren)
        );
      }
    }
  }
  const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node.children) ? 3 : 1;
  let slots = createObjectExpression(
    slotsProperties.concat(
      createObjectProperty(
        `_`,
        // 2 = compiled but dynamic = can skip normalization, but must run diff
        // 1 = compiled and static = can skip normalization AND diff as optimized
        createSimpleExpression(
          slotFlag + (true ? ` /* ${slotFlagsText[slotFlag]} */` : ``),
          false
        )
      )
    ),
    loc
  );
  if (dynamicSlots.length) {
    slots = createCallExpression(context.helper(CREATE_SLOTS), [
      slots,
      createArrayExpression(dynamicSlots)
    ]);
  }
  return {
    slots,
    hasDynamicSlots
  };
}
function buildDynamicSlot(name, fn, index) {
  const props = [
    createObjectProperty(`name`, name),
    createObjectProperty(`fn`, fn)
  ];
  if (index != null) {
    props.push(
      createObjectProperty(`key`, createSimpleExpression(String(index), true))
    );
  }
  return createObjectExpression(props);
}
function hasForwardedSlots(children) {
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    switch (child.type) {
      case 1:
        if (child.tagType === 2 || hasForwardedSlots(child.children)) {
          return true;
        }
        break;
      case 9:
        if (hasForwardedSlots(child.branches))
          return true;
        break;
      case 10:
      case 11:
        if (hasForwardedSlots(child.children))
          return true;
        break;
    }
  }
  return false;
}
function isNonWhitespaceContent(node) {
  if (node.type !== 2 && node.type !== 12)
    return true;
  return node.type === 2 ? !!node.content.trim() : isNonWhitespaceContent(node.content);
}
function resolveComponentType(node, context, ssr = false) {
  let { tag } = node;
  const isExplicitDynamic = isComponentTag(tag);
  const isProp = findProp(node, "is");
  if (isProp) {
    if (isExplicitDynamic || isCompatEnabled(
      "COMPILER_IS_ON_ELEMENT",
      context
    )) {
      const exp = isProp.type === 6 ? isProp.value && createSimpleExpression(isProp.value.content, true) : isProp.exp;
      if (exp) {
        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
          exp
        ]);
      }
    } else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) {
      tag = isProp.value.content.slice(4);
    }
  }
  const isDir = !isExplicitDynamic && findDir(node, "is");
  if (isDir && isDir.exp) {
    if (true) {
      context.onWarn(
        createCompilerError(52, isDir.loc)
      );
    }
    return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
      isDir.exp
    ]);
  }
  const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
  if (builtIn) {
    if (!ssr)
      context.helper(builtIn);
    return builtIn;
  }
  context.helper(RESOLVE_COMPONENT);
  context.components.add(tag);
  return toValidAssetId(tag, `component`);
}
function buildProps(node, context, props = node.props, isComponent2, isDynamicComponent, ssr = false) {
  const { tag, loc: elementLoc, children } = node;
  let properties = [];
  const mergeArgs = [];
  const runtimeDirectives = [];
  const hasChildren = children.length > 0;
  let shouldUseBlock = false;
  let patchFlag = 0;
  let hasRef = false;
  let hasClassBinding = false;
  let hasStyleBinding = false;
  let hasHydrationEventBinding = false;
  let hasDynamicKeys = false;
  let hasVnodeHook = false;
  const dynamicPropNames = [];
  const pushMergeArg = (arg) => {
    if (properties.length) {
      mergeArgs.push(
        createObjectExpression(dedupeProperties(properties), elementLoc)
      );
      properties = [];
    }
    if (arg)
      mergeArgs.push(arg);
  };
  const analyzePatchFlag = ({ key, value }) => {
    if (isStaticExp(key)) {
      const name = key.content;
      const isEventHandler = isOn(name);
      if (isEventHandler && (!isComponent2 || isDynamicComponent) && // omit the flag for click handlers because hydration gives click
      // dedicated fast path.
      name.toLowerCase() !== "onclick" && // omit v-model handlers
      name !== "onUpdate:modelValue" && // omit onVnodeXXX hooks
      !isReservedProp(name)) {
        hasHydrationEventBinding = true;
      }
      if (isEventHandler && isReservedProp(name)) {
        hasVnodeHook = true;
      }
      if (value.type === 20 || (value.type === 4 || value.type === 8) && getConstantType(value, context) > 0) {
        return;
      }
      if (name === "ref") {
        hasRef = true;
      } else if (name === "class") {
        hasClassBinding = true;
      } else if (name === "style") {
        hasStyleBinding = true;
      } else if (name !== "key" && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
      if (isComponent2 && (name === "class" || name === "style") && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
    } else {
      hasDynamicKeys = true;
    }
  };
  for (let i = 0; i < props.length; i++) {
    const prop = props[i];
    if (prop.type === 6) {
      const { loc, name, value } = prop;
      let isStatic = true;
      if (name === "ref") {
        hasRef = true;
        if (context.scopes.vFor > 0) {
          properties.push(
            createObjectProperty(
              createSimpleExpression("ref_for", true),
              createSimpleExpression("true")
            )
          );
        }
      }
      if (name === "is" && (isComponentTag(tag) || value && value.content.startsWith("vue:") || isCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        context
      ))) {
        continue;
      }
      properties.push(
        createObjectProperty(
          createSimpleExpression(
            name,
            true,
            getInnerRange(loc, 0, name.length)
          ),
          createSimpleExpression(
            value ? value.content : "",
            isStatic,
            value ? value.loc : loc
          )
        )
      );
    } else {
      const { name, arg, exp, loc } = prop;
      const isVBind = name === "bind";
      const isVOn = name === "on";
      if (name === "slot") {
        if (!isComponent2) {
          context.onError(
            createCompilerError(40, loc)
          );
        }
        continue;
      }
      if (name === "once" || name === "memo") {
        continue;
      }
      if (name === "is" || isVBind && isStaticArgOf(arg, "is") && (isComponentTag(tag) || isCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        context
      ))) {
        continue;
      }
      if (isVOn && ssr) {
        continue;
      }
      if (
        // #938: elements with dynamic keys should be forced into blocks
        isVBind && isStaticArgOf(arg, "key") || // inline before-update hooks need to force block so that it is invoked
        // before children
        isVOn && hasChildren && isStaticArgOf(arg, "vue:before-update")
      ) {
        shouldUseBlock = true;
      }
      if (isVBind && isStaticArgOf(arg, "ref") && context.scopes.vFor > 0) {
        properties.push(
          createObjectProperty(
            createSimpleExpression("ref_for", true),
            createSimpleExpression("true")
          )
        );
      }
      if (!arg && (isVBind || isVOn)) {
        hasDynamicKeys = true;
        if (exp) {
          if (isVBind) {
            pushMergeArg();
            {
              if (true) {
                const hasOverridableKeys = mergeArgs.some((arg2) => {
                  if (arg2.type === 15) {
                    return arg2.properties.some(({ key }) => {
                      if (key.type !== 4 || !key.isStatic) {
                        return true;
                      }
                      return key.content !== "class" && key.content !== "style" && !isOn(key.content);
                    });
                  } else {
                    return true;
                  }
                });
                if (hasOverridableKeys) {
                  checkCompatEnabled(
                    "COMPILER_V_BIND_OBJECT_ORDER",
                    context,
                    loc
                  );
                }
              }
              if (isCompatEnabled(
                "COMPILER_V_BIND_OBJECT_ORDER",
                context
              )) {
                mergeArgs.unshift(exp);
                continue;
              }
            }
            mergeArgs.push(exp);
          } else {
            pushMergeArg({
              type: 14,
              loc,
              callee: context.helper(TO_HANDLERS),
              arguments: isComponent2 ? [exp] : [exp, `true`]
            });
          }
        } else {
          context.onError(
            createCompilerError(
              isVBind ? 34 : 35,
              loc
            )
          );
        }
        continue;
      }
      const directiveTransform = context.directiveTransforms[name];
      if (directiveTransform) {
        const { props: props2, needRuntime } = directiveTransform(prop, node, context);
        !ssr && props2.forEach(analyzePatchFlag);
        if (isVOn && arg && !isStaticExp(arg)) {
          pushMergeArg(createObjectExpression(props2, elementLoc));
        } else {
          properties.push(...props2);
        }
        if (needRuntime) {
          runtimeDirectives.push(prop);
          if (isSymbol(needRuntime)) {
            directiveImportMap.set(prop, needRuntime);
          }
        }
      } else if (!isBuiltInDirective(name)) {
        runtimeDirectives.push(prop);
        if (hasChildren) {
          shouldUseBlock = true;
        }
      }
    }
  }
  let propsExpression = void 0;
  if (mergeArgs.length) {
    pushMergeArg();
    if (mergeArgs.length > 1) {
      propsExpression = createCallExpression(
        context.helper(MERGE_PROPS),
        mergeArgs,
        elementLoc
      );
    } else {
      propsExpression = mergeArgs[0];
    }
  } else if (properties.length) {
    propsExpression = createObjectExpression(
      dedupeProperties(properties),
      elementLoc
    );
  }
  if (hasDynamicKeys) {
    patchFlag |= 16;
  } else {
    if (hasClassBinding && !isComponent2) {
      patchFlag |= 2;
    }
    if (hasStyleBinding && !isComponent2) {
      patchFlag |= 4;
    }
    if (dynamicPropNames.length) {
      patchFlag |= 8;
    }
    if (hasHydrationEventBinding) {
      patchFlag |= 32;
    }
  }
  if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
    patchFlag |= 512;
  }
  if (!context.inSSR && propsExpression) {
    switch (propsExpression.type) {
      case 15:
        let classKeyIndex = -1;
        let styleKeyIndex = -1;
        let hasDynamicKey = false;
        for (let i = 0; i < propsExpression.properties.length; i++) {
          const key = propsExpression.properties[i].key;
          if (isStaticExp(key)) {
            if (key.content === "class") {
              classKeyIndex = i;
            } else if (key.content === "style") {
              styleKeyIndex = i;
            }
          } else if (!key.isHandlerKey) {
            hasDynamicKey = true;
          }
        }
        const classProp = propsExpression.properties[classKeyIndex];
        const styleProp = propsExpression.properties[styleKeyIndex];
        if (!hasDynamicKey) {
          if (classProp && !isStaticExp(classProp.value)) {
            classProp.value = createCallExpression(
              context.helper(NORMALIZE_CLASS),
              [classProp.value]
            );
          }
          if (styleProp && // the static style is compiled into an object,
          // so use `hasStyleBinding` to ensure that it is a dynamic style binding
          (hasStyleBinding || styleProp.value.type === 4 && styleProp.value.content.trim()[0] === `[` || // v-bind:style and style both exist,
          // v-bind:style with static literal object
          styleProp.value.type === 17)) {
            styleProp.value = createCallExpression(
              context.helper(NORMALIZE_STYLE),
              [styleProp.value]
            );
          }
        } else {
          propsExpression = createCallExpression(
            context.helper(NORMALIZE_PROPS),
            [propsExpression]
          );
        }
        break;
      case 14:
        break;
      default:
        propsExpression = createCallExpression(
          context.helper(NORMALIZE_PROPS),
          [
            createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
              propsExpression
            ])
          ]
        );
        break;
    }
  }
  return {
    props: propsExpression,
    directives: runtimeDirectives,
    patchFlag,
    dynamicPropNames,
    shouldUseBlock
  };
}
function dedupeProperties(properties) {
  const knownProps = /* @__PURE__ */ new Map();
  const deduped = [];
  for (let i = 0; i < properties.length; i++) {
    const prop = properties[i];
    if (prop.key.type === 8 || !prop.key.isStatic) {
      deduped.push(prop);
      continue;
    }
    const name = prop.key.content;
    const existing = knownProps.get(name);
    if (existing) {
      if (name === "style" || name === "class" || isOn(name)) {
        mergeAsArray(existing, prop);
      }
    } else {
      knownProps.set(name, prop);
      deduped.push(prop);
    }
  }
  return deduped;
}
function mergeAsArray(existing, incoming) {
  if (existing.value.type === 17) {
    existing.value.elements.push(incoming.value);
  } else {
    existing.value = createArrayExpression(
      [existing.value, incoming.value],
      existing.loc
    );
  }
}
function buildDirectiveArgs(dir, context) {
  const dirArgs = [];
  const runtime = directiveImportMap.get(dir);
  if (runtime) {
    dirArgs.push(context.helperString(runtime));
  } else {
    {
      context.helper(RESOLVE_DIRECTIVE);
      context.directives.add(dir.name);
      dirArgs.push(toValidAssetId(dir.name, `directive`));
    }
  }
  const { loc } = dir;
  if (dir.exp)
    dirArgs.push(dir.exp);
  if (dir.arg) {
    if (!dir.exp) {
      dirArgs.push(`void 0`);
    }
    dirArgs.push(dir.arg);
  }
  if (Object.keys(dir.modifiers).length) {
    if (!dir.arg) {
      if (!dir.exp) {
        dirArgs.push(`void 0`);
      }
      dirArgs.push(`void 0`);
    }
    const trueExpression = createSimpleExpression(`true`, false, loc);
    dirArgs.push(
      createObjectExpression(
        dir.modifiers.map(
          (modifier) => createObjectProperty(modifier, trueExpression)
        ),
        loc
      )
    );
  }
  return createArrayExpression(dirArgs, dir.loc);
}
function stringifyDynamicPropNames(props) {
  let propsNamesString = `[`;
  for (let i = 0, l = props.length; i < l; i++) {
    propsNamesString += JSON.stringify(props[i]);
    if (i < l - 1)
      propsNamesString += ", ";
  }
  return propsNamesString + `]`;
}
function isComponentTag(tag) {
  return tag === "component" || tag === "Component";
}
function processSlotOutlet(node, context) {
  let slotName = `"default"`;
  let slotProps = void 0;
  const nonNameProps = [];
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 6) {
      if (p.value) {
        if (p.name === "name") {
          slotName = JSON.stringify(p.value.content);
        } else {
          p.name = camelize(p.name);
          nonNameProps.push(p);
        }
      }
    } else {
      if (p.name === "bind" && isStaticArgOf(p.arg, "name")) {
        if (p.exp)
          slotName = p.exp;
      } else {
        if (p.name === "bind" && p.arg && isStaticExp(p.arg)) {
          p.arg.content = camelize(p.arg.content);
        }
        nonNameProps.push(p);
      }
    }
  }
  if (nonNameProps.length > 0) {
    const { props, directives } = buildProps(
      node,
      context,
      nonNameProps,
      false,
      false
    );
    slotProps = props;
    if (directives.length) {
      context.onError(
        createCompilerError(
          36,
          directives[0].loc
        )
      );
    }
  }
  return {
    slotName,
    slotProps
  };
}
function createTransformProps(props = []) {
  return { props };
}
function rewriteFilter(node, context) {
  if (node.type === 4) {
    parseFilter(node, context);
  } else {
    for (let i = 0; i < node.children.length; i++) {
      const child = node.children[i];
      if (typeof child !== "object")
        continue;
      if (child.type === 4) {
        parseFilter(child, context);
      } else if (child.type === 8) {
        rewriteFilter(node, context);
      } else if (child.type === 5) {
        rewriteFilter(child.content, context);
      }
    }
  }
}
function parseFilter(node, context) {
  const exp = node.content;
  let inSingle = false;
  let inDouble = false;
  let inTemplateString = false;
  let inRegex = false;
  let curly = 0;
  let square = 0;
  let paren = 0;
  let lastFilterIndex = 0;
  let c, prev, i, expression, filters = [];
  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 39 && prev !== 92)
        inSingle = false;
    } else if (inDouble) {
      if (c === 34 && prev !== 92)
        inDouble = false;
    } else if (inTemplateString) {
      if (c === 96 && prev !== 92)
        inTemplateString = false;
    } else if (inRegex) {
      if (c === 47 && prev !== 92)
        inRegex = false;
    } else if (c === 124 && // pipe
    exp.charCodeAt(i + 1) !== 124 && exp.charCodeAt(i - 1) !== 124 && !curly && !square && !paren) {
      if (expression === void 0) {
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 34:
          inDouble = true;
          break;
        case 39:
          inSingle = true;
          break;
        case 96:
          inTemplateString = true;
          break;
        case 40:
          paren++;
          break;
        case 41:
          paren--;
          break;
        case 91:
          square++;
          break;
        case 93:
          square--;
          break;
        case 123:
          curly++;
          break;
        case 125:
          curly--;
          break;
      }
      if (c === 47) {
        let j = i - 1;
        let p;
        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== " ")
            break;
        }
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }
  if (expression === void 0) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }
  function pushFilter() {
    filters.push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }
  if (filters.length) {
    warnDeprecation(
      "COMPILER_FILTER",
      context,
      node.loc
    );
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i], context);
    }
    node.content = expression;
  }
}
function wrapFilter(exp, filter, context) {
  context.helper(RESOLVE_FILTER);
  const i = filter.indexOf("(");
  if (i < 0) {
    context.filters.add(filter);
    return `${toValidAssetId(filter, "filter")}(${exp})`;
  } else {
    const name = filter.slice(0, i);
    const args = filter.slice(i + 1);
    context.filters.add(name);
    return `${toValidAssetId(name, "filter")}(${exp}${args !== ")" ? "," + args : args}`;
  }
}
function getBaseTransformPreset(prefixIdentifiers) {
  return [
    [
      transformOnce,
      transformIf,
      transformMemo,
      transformFor,
      ...[transformFilter],
      ...true ? [transformExpression] : [],
      transformSlotOutlet,
      transformElement,
      trackSlotScopes,
      transformText
    ],
    {
      on: transformOn,
      bind: transformBind,
      model: transformModel
    }
  ];
}
function baseCompile(template, options = {}) {
  const onError = options.onError || defaultOnError;
  const isModuleMode = options.mode === "module";
  {
    if (options.prefixIdentifiers === true) {
      onError(createCompilerError(47));
    } else if (isModuleMode) {
      onError(createCompilerError(48));
    }
  }
  const prefixIdentifiers = false;
  if (options.cacheHandlers) {
    onError(createCompilerError(49));
  }
  if (options.scopeId && !isModuleMode) {
    onError(createCompilerError(50));
  }
  const ast = isString(template) ? baseParse(template, options) : template;
  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
  transform(
    ast,
    extend({}, options, {
      prefixIdentifiers,
      nodeTransforms: [
        ...nodeTransforms,
        ...options.nodeTransforms || []
        // user transforms
      ],
      directiveTransforms: extend(
        {},
        directiveTransforms,
        options.directiveTransforms || {}
        // user transforms
      )
    })
  );
  return generate(
    ast,
    extend({}, options, {
      prefixIdentifiers
    })
  );
}
var errorMessages, FRAGMENT, TELEPORT, SUSPENSE, KEEP_ALIVE, BASE_TRANSITION, OPEN_BLOCK, CREATE_BLOCK, CREATE_ELEMENT_BLOCK, CREATE_VNODE, CREATE_ELEMENT_VNODE, CREATE_COMMENT, CREATE_TEXT, CREATE_STATIC, RESOLVE_COMPONENT, RESOLVE_DYNAMIC_COMPONENT, RESOLVE_DIRECTIVE, RESOLVE_FILTER, WITH_DIRECTIVES, RENDER_LIST, RENDER_SLOT, CREATE_SLOTS, TO_DISPLAY_STRING, MERGE_PROPS, NORMALIZE_CLASS, NORMALIZE_STYLE, NORMALIZE_PROPS, GUARD_REACTIVE_PROPS, TO_HANDLERS, CAMELIZE, CAPITALIZE, TO_HANDLER_KEY, SET_BLOCK_TRACKING, PUSH_SCOPE_ID, POP_SCOPE_ID, WITH_CTX, UNREF, IS_REF, WITH_MEMO, IS_MEMO_SAME, helperNameMap, locStub, isStaticExp, isBuiltInType, nonIdentifierRE, isSimpleIdentifier, validFirstIdentCharRE, validIdentCharRE, whitespaceRE, isMemberExpressionBrowser, isMemberExpressionNode, isMemberExpression, propsHelperSet, deprecationData, decodeRE, decodeMap, defaultParserOptions, TagType, isSpecialTemplateDirective, allowHoistedHelperSet, PURE_ANNOTATION, aliasHelper, isFunctionType, isStaticProperty, isStaticPropertyKey, TS_NODE_TYPES, prohibitedKeywordRE, stripStringRE, transformExpression, transformIf, transformFor, forAliasRE, forIteratorRE, stripParensRE, defaultFallback, trackSlotScopes, trackVForSlotScopes, buildClientSlotFn, directiveImportMap, transformElement, transformSlotOutlet, fnExpRE, transformOn, transformBind, injectPrefix, transformText, seen$1, transformOnce, transformModel, validDivisionCharRE, transformFilter, seen, transformMemo, noopDirectiveTransform;
var init_compiler_core_esm_bundler = __esm({
  "node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js"() {
    init_shared_esm_bundler();
    init_shared_esm_bundler();
    errorMessages = {
      // parse errors
      [0]: "Illegal comment.",
      [1]: "CDATA section is allowed only in XML context.",
      [2]: "Duplicate attribute.",
      [3]: "End tag cannot have attributes.",
      [4]: "Illegal '/' in tags.",
      [5]: "Unexpected EOF in tag.",
      [6]: "Unexpected EOF in CDATA section.",
      [7]: "Unexpected EOF in comment.",
      [8]: "Unexpected EOF in script.",
      [9]: "Unexpected EOF in tag.",
      [10]: "Incorrectly closed comment.",
      [11]: "Incorrectly opened comment.",
      [12]: "Illegal tag name. Use '&lt;' to print '<'.",
      [13]: "Attribute value was expected.",
      [14]: "End tag name was expected.",
      [15]: "Whitespace was expected.",
      [16]: "Unexpected '<!--' in comment.",
      [17]: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
      [18]: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
      [19]: "Attribute name cannot start with '='.",
      [21]: "'<?' is allowed only in XML context.",
      [20]: `Unexpected null character.`,
      [22]: "Illegal '/' in tags.",
      // Vue-specific parse errors
      [23]: "Invalid end tag.",
      [24]: "Element is missing end tag.",
      [25]: "Interpolation end sign was not found.",
      [27]: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
      [26]: "Legal directive name was expected.",
      // transform errors
      [28]: `v-if/v-else-if is missing expression.`,
      [29]: `v-if/else branches must use unique keys.`,
      [30]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,
      [31]: `v-for is missing expression.`,
      [32]: `v-for has invalid expression.`,
      [33]: `<template v-for> key should be placed on the <template> tag.`,
      [34]: `v-bind is missing expression.`,
      [35]: `v-on is missing expression.`,
      [36]: `Unexpected custom directive on <slot> outlet.`,
      [37]: `Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.`,
      [38]: `Duplicate slot names found. `,
      [39]: `Extraneous children found when component already has explicitly named default slot. These children will be ignored.`,
      [40]: `v-slot can only be used on components or <template> tags.`,
      [41]: `v-model is missing expression.`,
      [42]: `v-model value must be a valid JavaScript member expression.`,
      [43]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
      [44]: `v-model cannot be used on a prop, because local prop bindings are not writable.
Use a v-bind binding combined with a v-on listener that emits update:x event instead.`,
      [45]: `Error parsing JavaScript expression: `,
      [46]: `<KeepAlive> expects exactly one child component.`,
      // generic errors
      [47]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
      [48]: `ES module mode is not supported in this build of compiler.`,
      [49]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
      [50]: `"scopeId" option is only supported in module mode.`,
      // deprecations
      [51]: `@vnode-* hooks in templates are deprecated. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support will be removed in 3.4.`,
      [52]: `v-is="component-name" has been deprecated. Use is="vue:component-name" instead. v-is support will be removed in 3.4.`,
      // just to fulfill types
      [53]: ``
    };
    FRAGMENT = Symbol(true ? `Fragment` : ``);
    TELEPORT = Symbol(true ? `Teleport` : ``);
    SUSPENSE = Symbol(true ? `Suspense` : ``);
    KEEP_ALIVE = Symbol(true ? `KeepAlive` : ``);
    BASE_TRANSITION = Symbol(true ? `BaseTransition` : ``);
    OPEN_BLOCK = Symbol(true ? `openBlock` : ``);
    CREATE_BLOCK = Symbol(true ? `createBlock` : ``);
    CREATE_ELEMENT_BLOCK = Symbol(true ? `createElementBlock` : ``);
    CREATE_VNODE = Symbol(true ? `createVNode` : ``);
    CREATE_ELEMENT_VNODE = Symbol(true ? `createElementVNode` : ``);
    CREATE_COMMENT = Symbol(true ? `createCommentVNode` : ``);
    CREATE_TEXT = Symbol(true ? `createTextVNode` : ``);
    CREATE_STATIC = Symbol(true ? `createStaticVNode` : ``);
    RESOLVE_COMPONENT = Symbol(true ? `resolveComponent` : ``);
    RESOLVE_DYNAMIC_COMPONENT = Symbol(
      true ? `resolveDynamicComponent` : ``
    );
    RESOLVE_DIRECTIVE = Symbol(true ? `resolveDirective` : ``);
    RESOLVE_FILTER = Symbol(true ? `resolveFilter` : ``);
    WITH_DIRECTIVES = Symbol(true ? `withDirectives` : ``);
    RENDER_LIST = Symbol(true ? `renderList` : ``);
    RENDER_SLOT = Symbol(true ? `renderSlot` : ``);
    CREATE_SLOTS = Symbol(true ? `createSlots` : ``);
    TO_DISPLAY_STRING = Symbol(true ? `toDisplayString` : ``);
    MERGE_PROPS = Symbol(true ? `mergeProps` : ``);
    NORMALIZE_CLASS = Symbol(true ? `normalizeClass` : ``);
    NORMALIZE_STYLE = Symbol(true ? `normalizeStyle` : ``);
    NORMALIZE_PROPS = Symbol(true ? `normalizeProps` : ``);
    GUARD_REACTIVE_PROPS = Symbol(true ? `guardReactiveProps` : ``);
    TO_HANDLERS = Symbol(true ? `toHandlers` : ``);
    CAMELIZE = Symbol(true ? `camelize` : ``);
    CAPITALIZE = Symbol(true ? `capitalize` : ``);
    TO_HANDLER_KEY = Symbol(true ? `toHandlerKey` : ``);
    SET_BLOCK_TRACKING = Symbol(true ? `setBlockTracking` : ``);
    PUSH_SCOPE_ID = Symbol(true ? `pushScopeId` : ``);
    POP_SCOPE_ID = Symbol(true ? `popScopeId` : ``);
    WITH_CTX = Symbol(true ? `withCtx` : ``);
    UNREF = Symbol(true ? `unref` : ``);
    IS_REF = Symbol(true ? `isRef` : ``);
    WITH_MEMO = Symbol(true ? `withMemo` : ``);
    IS_MEMO_SAME = Symbol(true ? `isMemoSame` : ``);
    helperNameMap = {
      [FRAGMENT]: `Fragment`,
      [TELEPORT]: `Teleport`,
      [SUSPENSE]: `Suspense`,
      [KEEP_ALIVE]: `KeepAlive`,
      [BASE_TRANSITION]: `BaseTransition`,
      [OPEN_BLOCK]: `openBlock`,
      [CREATE_BLOCK]: `createBlock`,
      [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
      [CREATE_VNODE]: `createVNode`,
      [CREATE_ELEMENT_VNODE]: `createElementVNode`,
      [CREATE_COMMENT]: `createCommentVNode`,
      [CREATE_TEXT]: `createTextVNode`,
      [CREATE_STATIC]: `createStaticVNode`,
      [RESOLVE_COMPONENT]: `resolveComponent`,
      [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
      [RESOLVE_DIRECTIVE]: `resolveDirective`,
      [RESOLVE_FILTER]: `resolveFilter`,
      [WITH_DIRECTIVES]: `withDirectives`,
      [RENDER_LIST]: `renderList`,
      [RENDER_SLOT]: `renderSlot`,
      [CREATE_SLOTS]: `createSlots`,
      [TO_DISPLAY_STRING]: `toDisplayString`,
      [MERGE_PROPS]: `mergeProps`,
      [NORMALIZE_CLASS]: `normalizeClass`,
      [NORMALIZE_STYLE]: `normalizeStyle`,
      [NORMALIZE_PROPS]: `normalizeProps`,
      [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
      [TO_HANDLERS]: `toHandlers`,
      [CAMELIZE]: `camelize`,
      [CAPITALIZE]: `capitalize`,
      [TO_HANDLER_KEY]: `toHandlerKey`,
      [SET_BLOCK_TRACKING]: `setBlockTracking`,
      [PUSH_SCOPE_ID]: `pushScopeId`,
      [POP_SCOPE_ID]: `popScopeId`,
      [WITH_CTX]: `withCtx`,
      [UNREF]: `unref`,
      [IS_REF]: `isRef`,
      [WITH_MEMO]: `withMemo`,
      [IS_MEMO_SAME]: `isMemoSame`
    };
    locStub = {
      source: "",
      start: { line: 1, column: 1, offset: 0 },
      end: { line: 1, column: 1, offset: 0 }
    };
    isStaticExp = (p) => p.type === 4 && p.isStatic;
    isBuiltInType = (tag, expected) => tag === expected || tag === hyphenate(expected);
    nonIdentifierRE = /^\d|[^\$\w]/;
    isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
    validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
    validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
    whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
    isMemberExpressionBrowser = (path) => {
      path = path.trim().replace(whitespaceRE, (s) => s.trim());
      let state = 0;
      let stateStack = [];
      let currentOpenBracketCount = 0;
      let currentOpenParensCount = 0;
      let currentStringType = null;
      for (let i = 0; i < path.length; i++) {
        const char = path.charAt(i);
        switch (state) {
          case 0:
            if (char === "[") {
              stateStack.push(state);
              state = 1;
              currentOpenBracketCount++;
            } else if (char === "(") {
              stateStack.push(state);
              state = 2;
              currentOpenParensCount++;
            } else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
              return false;
            }
            break;
          case 1:
            if (char === `'` || char === `"` || char === "`") {
              stateStack.push(state);
              state = 3;
              currentStringType = char;
            } else if (char === `[`) {
              currentOpenBracketCount++;
            } else if (char === `]`) {
              if (!--currentOpenBracketCount) {
                state = stateStack.pop();
              }
            }
            break;
          case 2:
            if (char === `'` || char === `"` || char === "`") {
              stateStack.push(state);
              state = 3;
              currentStringType = char;
            } else if (char === `(`) {
              currentOpenParensCount++;
            } else if (char === `)`) {
              if (i === path.length - 1) {
                return false;
              }
              if (!--currentOpenParensCount) {
                state = stateStack.pop();
              }
            }
            break;
          case 3:
            if (char === currentStringType) {
              state = stateStack.pop();
              currentStringType = null;
            }
            break;
        }
      }
      return !currentOpenBracketCount && !currentOpenParensCount;
    };
    isMemberExpressionNode = NOOP;
    isMemberExpression = isMemberExpressionBrowser;
    propsHelperSet = /* @__PURE__ */ new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
    deprecationData = {
      ["COMPILER_IS_ON_ELEMENT"]: {
        message: `Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".`,
        link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`
      },
      ["COMPILER_V_BIND_SYNC"]: {
        message: (key) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${key}.sync\` should be changed to \`v-model:${key}\`.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`
      },
      ["COMPILER_V_BIND_PROP"]: {
        message: `.prop modifier for v-bind has been removed and no longer necessary. Vue 3 will automatically set a binding as DOM property when appropriate.`
      },
      ["COMPILER_V_BIND_OBJECT_ORDER"]: {
        message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`
      },
      ["COMPILER_V_ON_NATIVE"]: {
        message: `.native modifier for v-on has been removed as is no longer necessary.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`
      },
      ["COMPILER_V_IF_V_FOR_PRECEDENCE"]: {
        message: `v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`
      },
      ["COMPILER_NATIVE_TEMPLATE"]: {
        message: `<template> with no special directives will render as a native template element instead of its inner content in Vue 3.`
      },
      ["COMPILER_INLINE_TEMPLATE"]: {
        message: `"inline-template" has been removed in Vue 3.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`
      },
      ["COMPILER_FILTER"]: {
        message: `filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`
      }
    };
    decodeRE = /&(gt|lt|amp|apos|quot);/g;
    decodeMap = {
      gt: ">",
      lt: "<",
      amp: "&",
      apos: "'",
      quot: '"'
    };
    defaultParserOptions = {
      delimiters: [`{{`, `}}`],
      getNamespace: () => 0,
      getTextMode: () => 0,
      isVoidTag: NO,
      isPreTag: NO,
      isCustomElement: NO,
      decodeEntities: (rawText) => rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),
      onError: defaultOnError,
      onWarn: defaultOnWarn,
      comments: true
    };
    TagType = ((TagType2) => {
      TagType2[TagType2["Start"] = 0] = "Start";
      TagType2[TagType2["End"] = 1] = "End";
      return TagType2;
    })(TagType || {});
    isSpecialTemplateDirective = makeMap(
      `if,else,else-if,for,slot`
    );
    allowHoistedHelperSet = /* @__PURE__ */ new Set([
      NORMALIZE_CLASS,
      NORMALIZE_STYLE,
      NORMALIZE_PROPS,
      GUARD_REACTIVE_PROPS
    ]);
    PURE_ANNOTATION = `/*#__PURE__*/`;
    aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
    isFunctionType = (node) => {
      return /Function(?:Expression|Declaration)$|Method$/.test(node.type);
    };
    isStaticProperty = (node) => node && (node.type === "ObjectProperty" || node.type === "ObjectMethod") && !node.computed;
    isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;
    TS_NODE_TYPES = [
      "TSAsExpression",
      // foo as number
      "TSTypeAssertion",
      // (<number>foo)
      "TSNonNullExpression",
      // foo!
      "TSInstantiationExpression",
      // foo<string>
      "TSSatisfiesExpression"
      // foo satisfies T
    ];
    prohibitedKeywordRE = new RegExp(
      "\\b" + "arguments,await,break,case,catch,class,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,let,new,return,super,switch,throw,try,var,void,while,with,yield".split(",").join("\\b|\\b") + "\\b"
    );
    stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
    transformExpression = (node, context) => {
      if (node.type === 5) {
        node.content = processExpression(
          node.content,
          context
        );
      } else if (node.type === 1) {
        for (let i = 0; i < node.props.length; i++) {
          const dir = node.props[i];
          if (dir.type === 7 && dir.name !== "for") {
            const exp = dir.exp;
            const arg = dir.arg;
            if (exp && exp.type === 4 && !(dir.name === "on" && arg)) {
              dir.exp = processExpression(
                exp,
                context,
                // slot args must be processed as function params
                dir.name === "slot"
              );
            }
            if (arg && arg.type === 4 && !arg.isStatic) {
              dir.arg = processExpression(arg, context);
            }
          }
        }
      }
    };
    transformIf = createStructuralDirectiveTransform(
      /^(if|else|else-if)$/,
      (node, dir, context) => {
        return processIf(node, dir, context, (ifNode, branch, isRoot) => {
          const siblings = context.parent.children;
          let i = siblings.indexOf(ifNode);
          let key = 0;
          while (i-- >= 0) {
            const sibling = siblings[i];
            if (sibling && sibling.type === 9) {
              key += sibling.branches.length;
            }
          }
          return () => {
            if (isRoot) {
              ifNode.codegenNode = createCodegenNodeForBranch(
                branch,
                key,
                context
              );
            } else {
              const parentCondition = getParentCondition(ifNode.codegenNode);
              parentCondition.alternate = createCodegenNodeForBranch(
                branch,
                key + ifNode.branches.length - 1,
                context
              );
            }
          };
        });
      }
    );
    transformFor = createStructuralDirectiveTransform(
      "for",
      (node, dir, context) => {
        const { helper, removeHelper } = context;
        return processFor(node, dir, context, (forNode) => {
          const renderExp = createCallExpression(helper(RENDER_LIST), [
            forNode.source
          ]);
          const isTemplate = isTemplateNode(node);
          const memo = findDir(node, "memo");
          const keyProp = findProp(node, `key`);
          const keyExp = keyProp && (keyProp.type === 6 ? createSimpleExpression(keyProp.value.content, true) : keyProp.exp);
          const keyProperty = keyProp ? createObjectProperty(`key`, keyExp) : null;
          const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
          const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
          forNode.codegenNode = createVNodeCall(
            context,
            helper(FRAGMENT),
            void 0,
            renderExp,
            fragmentFlag + (true ? ` /* ${PatchFlagNames[fragmentFlag]} */` : ``),
            void 0,
            void 0,
            true,
            !isStableFragment,
            false,
            node.loc
          );
          return () => {
            let childBlock;
            const { children } = forNode;
            if (isTemplate) {
              node.children.some((c) => {
                if (c.type === 1) {
                  const key = findProp(c, "key");
                  if (key) {
                    context.onError(
                      createCompilerError(
                        33,
                        key.loc
                      )
                    );
                    return true;
                  }
                }
              });
            }
            const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;
            const slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] : null;
            if (slotOutlet) {
              childBlock = slotOutlet.codegenNode;
              if (isTemplate && keyProperty) {
                injectProp(childBlock, keyProperty, context);
              }
            } else if (needFragmentWrapper) {
              childBlock = createVNodeCall(
                context,
                helper(FRAGMENT),
                keyProperty ? createObjectExpression([keyProperty]) : void 0,
                node.children,
                64 + (true ? ` /* ${PatchFlagNames[64]} */` : ``),
                void 0,
                void 0,
                true,
                void 0,
                false
                /* isComponent */
              );
            } else {
              childBlock = children[0].codegenNode;
              if (isTemplate && keyProperty) {
                injectProp(childBlock, keyProperty, context);
              }
              if (childBlock.isBlock !== !isStableFragment) {
                if (childBlock.isBlock) {
                  removeHelper(OPEN_BLOCK);
                  removeHelper(
                    getVNodeBlockHelper(context.inSSR, childBlock.isComponent)
                  );
                } else {
                  removeHelper(
                    getVNodeHelper(context.inSSR, childBlock.isComponent)
                  );
                }
              }
              childBlock.isBlock = !isStableFragment;
              if (childBlock.isBlock) {
                helper(OPEN_BLOCK);
                helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
              } else {
                helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
              }
            }
            if (memo) {
              const loop = createFunctionExpression(
                createForLoopParams(forNode.parseResult, [
                  createSimpleExpression(`_cached`)
                ])
              );
              loop.body = createBlockStatement([
                createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
                createCompoundExpression([
                  `if (_cached`,
                  ...keyExp ? [` && _cached.key === `, keyExp] : [],
                  ` && ${context.helperString(
                    IS_MEMO_SAME
                  )}(_cached, _memo)) return _cached`
                ]),
                createCompoundExpression([`const _item = `, childBlock]),
                createSimpleExpression(`_item.memo = _memo`),
                createSimpleExpression(`return _item`)
              ]);
              renderExp.arguments.push(
                loop,
                createSimpleExpression(`_cache`),
                createSimpleExpression(String(context.cached++))
              );
            } else {
              renderExp.arguments.push(
                createFunctionExpression(
                  createForLoopParams(forNode.parseResult),
                  childBlock,
                  true
                  /* force newline */
                )
              );
            }
          };
        });
      }
    );
    forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
    forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
    stripParensRE = /^\(|\)$/g;
    defaultFallback = createSimpleExpression(`undefined`, false);
    trackSlotScopes = (node, context) => {
      if (node.type === 1 && (node.tagType === 1 || node.tagType === 3)) {
        const vSlot = findDir(node, "slot");
        if (vSlot) {
          vSlot.exp;
          context.scopes.vSlot++;
          return () => {
            context.scopes.vSlot--;
          };
        }
      }
    };
    trackVForSlotScopes = (node, context) => {
      let vFor;
      if (isTemplateNode(node) && node.props.some(isVSlot) && (vFor = findDir(node, "for"))) {
        const result = vFor.parseResult = parseForExpression(
          vFor.exp,
          context
        );
        if (result) {
          const { value, key, index } = result;
          const { addIdentifiers, removeIdentifiers } = context;
          value && addIdentifiers(value);
          key && addIdentifiers(key);
          index && addIdentifiers(index);
          return () => {
            value && removeIdentifiers(value);
            key && removeIdentifiers(key);
            index && removeIdentifiers(index);
          };
        }
      }
    };
    buildClientSlotFn = (props, children, loc) => createFunctionExpression(
      props,
      children,
      false,
      true,
      children.length ? children[0].loc : loc
    );
    directiveImportMap = /* @__PURE__ */ new WeakMap();
    transformElement = (node, context) => {
      return function postTransformElement() {
        node = context.currentNode;
        if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1))) {
          return;
        }
        const { tag, props } = node;
        const isComponent2 = node.tagType === 1;
        let vnodeTag = isComponent2 ? resolveComponentType(node, context) : `"${tag}"`;
        const isDynamicComponent = isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
        let vnodeProps;
        let vnodeChildren;
        let vnodePatchFlag;
        let patchFlag = 0;
        let vnodeDynamicProps;
        let dynamicPropNames;
        let vnodeDirectives;
        let shouldUseBlock = (
          // dynamic component may resolve to plain elements
          isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent2 && // <svg> and <foreignObject> must be forced into blocks so that block
          // updates inside get proper isSVG flag at runtime. (#639, #643)
          // This is technically web-specific, but splitting the logic out of core
          // leads to too much unnecessary complexity.
          (tag === "svg" || tag === "foreignObject")
        );
        if (props.length > 0) {
          const propsBuildResult = buildProps(
            node,
            context,
            void 0,
            isComponent2,
            isDynamicComponent
          );
          vnodeProps = propsBuildResult.props;
          patchFlag = propsBuildResult.patchFlag;
          dynamicPropNames = propsBuildResult.dynamicPropNames;
          const directives = propsBuildResult.directives;
          vnodeDirectives = directives && directives.length ? createArrayExpression(
            directives.map((dir) => buildDirectiveArgs(dir, context))
          ) : void 0;
          if (propsBuildResult.shouldUseBlock) {
            shouldUseBlock = true;
          }
        }
        if (node.children.length > 0) {
          if (vnodeTag === KEEP_ALIVE) {
            shouldUseBlock = true;
            patchFlag |= 1024;
            if (node.children.length > 1) {
              context.onError(
                createCompilerError(46, {
                  start: node.children[0].loc.start,
                  end: node.children[node.children.length - 1].loc.end,
                  source: ""
                })
              );
            }
          }
          const shouldBuildAsSlots = isComponent2 && // Teleport is not a real component and has dedicated runtime handling
          vnodeTag !== TELEPORT && // explained above.
          vnodeTag !== KEEP_ALIVE;
          if (shouldBuildAsSlots) {
            const { slots, hasDynamicSlots } = buildSlots(node, context);
            vnodeChildren = slots;
            if (hasDynamicSlots) {
              patchFlag |= 1024;
            }
          } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
            const child = node.children[0];
            const type = child.type;
            const hasDynamicTextChild = type === 5 || type === 8;
            if (hasDynamicTextChild && getConstantType(child, context) === 0) {
              patchFlag |= 1;
            }
            if (hasDynamicTextChild || type === 2) {
              vnodeChildren = child;
            } else {
              vnodeChildren = node.children;
            }
          } else {
            vnodeChildren = node.children;
          }
        }
        if (patchFlag !== 0) {
          if (true) {
            if (patchFlag < 0) {
              vnodePatchFlag = patchFlag + ` /* ${PatchFlagNames[patchFlag]} */`;
            } else {
              const flagNames = Object.keys(PatchFlagNames).map(Number).filter((n) => n > 0 && patchFlag & n).map((n) => PatchFlagNames[n]).join(`, `);
              vnodePatchFlag = patchFlag + ` /* ${flagNames} */`;
            }
          } else {
            vnodePatchFlag = String(patchFlag);
          }
          if (dynamicPropNames && dynamicPropNames.length) {
            vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
          }
        }
        node.codegenNode = createVNodeCall(
          context,
          vnodeTag,
          vnodeProps,
          vnodeChildren,
          vnodePatchFlag,
          vnodeDynamicProps,
          vnodeDirectives,
          !!shouldUseBlock,
          false,
          isComponent2,
          node.loc
        );
      };
    };
    transformSlotOutlet = (node, context) => {
      if (isSlotOutlet(node)) {
        const { children, loc } = node;
        const { slotName, slotProps } = processSlotOutlet(node, context);
        const slotArgs = [
          context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
          slotName,
          "{}",
          "undefined",
          "true"
        ];
        let expectedLen = 2;
        if (slotProps) {
          slotArgs[2] = slotProps;
          expectedLen = 3;
        }
        if (children.length) {
          slotArgs[3] = createFunctionExpression([], children, false, false, loc);
          expectedLen = 4;
        }
        if (context.scopeId && !context.slotted) {
          expectedLen = 5;
        }
        slotArgs.splice(expectedLen);
        node.codegenNode = createCallExpression(
          context.helper(RENDER_SLOT),
          slotArgs,
          loc
        );
      }
    };
    fnExpRE = /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
    transformOn = (dir, node, context, augmentor) => {
      const { loc, modifiers, arg } = dir;
      if (!dir.exp && !modifiers.length) {
        context.onError(createCompilerError(35, loc));
      }
      let eventName;
      if (arg.type === 4) {
        if (arg.isStatic) {
          let rawName = arg.content;
          if (rawName.startsWith("vnode")) {
            context.onWarn(
              createCompilerError(51, arg.loc)
            );
          }
          if (rawName.startsWith("vue:")) {
            rawName = `vnode-${rawName.slice(4)}`;
          }
          const eventString = node.tagType !== 0 || rawName.startsWith("vnode") || !/[A-Z]/.test(rawName) ? (
            // for non-element and vnode lifecycle event listeners, auto convert
            // it to camelCase. See issue #2249
            toHandlerKey(camelize(rawName))
          ) : (
            // preserve case for plain element listeners that have uppercase
            // letters, as these may be custom elements' custom events
            `on:${rawName}`
          );
          eventName = createSimpleExpression(eventString, true, arg.loc);
        } else {
          eventName = createCompoundExpression([
            `${context.helperString(TO_HANDLER_KEY)}(`,
            arg,
            `)`
          ]);
        }
      } else {
        eventName = arg;
        eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
        eventName.children.push(`)`);
      }
      let exp = dir.exp;
      if (exp && !exp.content.trim()) {
        exp = void 0;
      }
      let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
      if (exp) {
        const isMemberExp = isMemberExpression(exp.content);
        const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
        const hasMultipleStatements = exp.content.includes(`;`);
        if (true) {
          validateBrowserExpression(
            exp,
            context,
            false,
            hasMultipleStatements
          );
        }
        if (isInlineStatement || shouldCache && isMemberExp) {
          exp = createCompoundExpression([
            `${isInlineStatement ? `$event` : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
            exp,
            hasMultipleStatements ? `}` : `)`
          ]);
        }
      }
      let ret = {
        props: [
          createObjectProperty(
            eventName,
            exp || createSimpleExpression(`() => {}`, false, loc)
          )
        ]
      };
      if (augmentor) {
        ret = augmentor(ret);
      }
      if (shouldCache) {
        ret.props[0].value = context.cache(ret.props[0].value);
      }
      ret.props.forEach((p) => p.key.isHandlerKey = true);
      return ret;
    };
    transformBind = (dir, _node, context) => {
      const { exp, modifiers, loc } = dir;
      const arg = dir.arg;
      if (arg.type !== 4) {
        arg.children.unshift(`(`);
        arg.children.push(`) || ""`);
      } else if (!arg.isStatic) {
        arg.content = `${arg.content} || ""`;
      }
      if (modifiers.includes("camel")) {
        if (arg.type === 4) {
          if (arg.isStatic) {
            arg.content = camelize(arg.content);
          } else {
            arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
          }
        } else {
          arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
          arg.children.push(`)`);
        }
      }
      if (!context.inSSR) {
        if (modifiers.includes("prop")) {
          injectPrefix(arg, ".");
        }
        if (modifiers.includes("attr")) {
          injectPrefix(arg, "^");
        }
      }
      if (!exp || exp.type === 4 && !exp.content.trim()) {
        context.onError(createCompilerError(34, loc));
        return {
          props: [createObjectProperty(arg, createSimpleExpression("", true, loc))]
        };
      }
      return {
        props: [createObjectProperty(arg, exp)]
      };
    };
    injectPrefix = (arg, prefix) => {
      if (arg.type === 4) {
        if (arg.isStatic) {
          arg.content = prefix + arg.content;
        } else {
          arg.content = `\`${prefix}\${${arg.content}}\``;
        }
      } else {
        arg.children.unshift(`'${prefix}' + (`);
        arg.children.push(`)`);
      }
    };
    transformText = (node, context) => {
      if (node.type === 0 || node.type === 1 || node.type === 11 || node.type === 10) {
        return () => {
          const children = node.children;
          let currentContainer = void 0;
          let hasText = false;
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (isText$1(child)) {
              hasText = true;
              for (let j = i + 1; j < children.length; j++) {
                const next = children[j];
                if (isText$1(next)) {
                  if (!currentContainer) {
                    currentContainer = children[i] = createCompoundExpression(
                      [child],
                      child.loc
                    );
                  }
                  currentContainer.children.push(` + `, next);
                  children.splice(j, 1);
                  j--;
                } else {
                  currentContainer = void 0;
                  break;
                }
              }
            }
          }
          if (!hasText || // if this is a plain element with a single text child, leave it
          // as-is since the runtime has dedicated fast path for this by directly
          // setting textContent of the element.
          // for component root it's always normalized anyway.
          children.length === 1 && (node.type === 0 || node.type === 1 && node.tagType === 0 && // #3756
          // custom directives can potentially add DOM elements arbitrarily,
          // we need to avoid setting textContent of the element at runtime
          // to avoid accidentally overwriting the DOM elements added
          // by the user through custom directives.
          !node.props.find(
            (p) => p.type === 7 && !context.directiveTransforms[p.name]
          ) && // in compat mode, <template> tags with no special directives
          // will be rendered as a fragment so its children must be
          // converted into vnodes.
          !(node.tag === "template"))) {
            return;
          }
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (isText$1(child) || child.type === 8) {
              const callArgs = [];
              if (child.type !== 2 || child.content !== " ") {
                callArgs.push(child);
              }
              if (!context.ssr && getConstantType(child, context) === 0) {
                callArgs.push(
                  1 + (true ? ` /* ${PatchFlagNames[1]} */` : ``)
                );
              }
              children[i] = {
                type: 12,
                content: child,
                loc: child.loc,
                codegenNode: createCallExpression(
                  context.helper(CREATE_TEXT),
                  callArgs
                )
              };
            }
          }
        };
      }
    };
    seen$1 = /* @__PURE__ */ new WeakSet();
    transformOnce = (node, context) => {
      if (node.type === 1 && findDir(node, "once", true)) {
        if (seen$1.has(node) || context.inVOnce || context.inSSR) {
          return;
        }
        seen$1.add(node);
        context.inVOnce = true;
        context.helper(SET_BLOCK_TRACKING);
        return () => {
          context.inVOnce = false;
          const cur = context.currentNode;
          if (cur.codegenNode) {
            cur.codegenNode = context.cache(
              cur.codegenNode,
              true
              /* isVNode */
            );
          }
        };
      }
    };
    transformModel = (dir, node, context) => {
      const { exp, arg } = dir;
      if (!exp) {
        context.onError(
          createCompilerError(41, dir.loc)
        );
        return createTransformProps();
      }
      const rawExp = exp.loc.source;
      const expString = exp.type === 4 ? exp.content : rawExp;
      const bindingType = context.bindingMetadata[rawExp];
      if (bindingType === "props" || bindingType === "props-aliased") {
        context.onError(createCompilerError(44, exp.loc));
        return createTransformProps();
      }
      const maybeRef = false;
      if (!expString.trim() || !isMemberExpression(expString) && !maybeRef) {
        context.onError(
          createCompilerError(42, exp.loc)
        );
        return createTransformProps();
      }
      const propName = arg ? arg : createSimpleExpression("modelValue", true);
      const eventName = arg ? isStaticExp(arg) ? `onUpdate:${camelize(arg.content)}` : createCompoundExpression(['"onUpdate:" + ', arg]) : `onUpdate:modelValue`;
      let assignmentExp;
      const eventArg = context.isTS ? `($event: any)` : `$event`;
      {
        assignmentExp = createCompoundExpression([
          `${eventArg} => ((`,
          exp,
          `) = $event)`
        ]);
      }
      const props = [
        // modelValue: foo
        createObjectProperty(propName, dir.exp),
        // "onUpdate:modelValue": $event => (foo = $event)
        createObjectProperty(eventName, assignmentExp)
      ];
      if (dir.modifiers.length && node.tagType === 1) {
        const modifiers = dir.modifiers.map((m) => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`).join(`, `);
        const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + "Modifiers"']) : `modelModifiers`;
        props.push(
          createObjectProperty(
            modifiersKey,
            createSimpleExpression(
              `{ ${modifiers} }`,
              false,
              dir.loc,
              2
            )
          )
        );
      }
      return createTransformProps(props);
    };
    validDivisionCharRE = /[\w).+\-_$\]]/;
    transformFilter = (node, context) => {
      if (!isCompatEnabled("COMPILER_FILTER", context)) {
        return;
      }
      if (node.type === 5) {
        rewriteFilter(node.content, context);
      }
      if (node.type === 1) {
        node.props.forEach((prop) => {
          if (prop.type === 7 && prop.name !== "for" && prop.exp) {
            rewriteFilter(prop.exp, context);
          }
        });
      }
    };
    seen = /* @__PURE__ */ new WeakSet();
    transformMemo = (node, context) => {
      if (node.type === 1) {
        const dir = findDir(node, "memo");
        if (!dir || seen.has(node)) {
          return;
        }
        seen.add(node);
        return () => {
          const codegenNode = node.codegenNode || context.currentNode.codegenNode;
          if (codegenNode && codegenNode.type === 13) {
            if (node.tagType !== 1) {
              convertToBlock(codegenNode, context);
            }
            node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
              dir.exp,
              createFunctionExpression(void 0, codegenNode),
              `_cache`,
              String(context.cached++)
            ]);
          }
        };
      }
    };
    noopDirectiveTransform = () => ({ props: [] });
  }
});

// node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js
var compiler_dom_esm_bundler_exports = {};
__export(compiler_dom_esm_bundler_exports, {
  BASE_TRANSITION: () => BASE_TRANSITION,
  CAMELIZE: () => CAMELIZE,
  CAPITALIZE: () => CAPITALIZE,
  CREATE_BLOCK: () => CREATE_BLOCK,
  CREATE_COMMENT: () => CREATE_COMMENT,
  CREATE_ELEMENT_BLOCK: () => CREATE_ELEMENT_BLOCK,
  CREATE_ELEMENT_VNODE: () => CREATE_ELEMENT_VNODE,
  CREATE_SLOTS: () => CREATE_SLOTS,
  CREATE_STATIC: () => CREATE_STATIC,
  CREATE_TEXT: () => CREATE_TEXT,
  CREATE_VNODE: () => CREATE_VNODE,
  DOMDirectiveTransforms: () => DOMDirectiveTransforms,
  DOMNodeTransforms: () => DOMNodeTransforms,
  FRAGMENT: () => FRAGMENT,
  GUARD_REACTIVE_PROPS: () => GUARD_REACTIVE_PROPS,
  IS_MEMO_SAME: () => IS_MEMO_SAME,
  IS_REF: () => IS_REF,
  KEEP_ALIVE: () => KEEP_ALIVE,
  MERGE_PROPS: () => MERGE_PROPS,
  NORMALIZE_CLASS: () => NORMALIZE_CLASS,
  NORMALIZE_PROPS: () => NORMALIZE_PROPS,
  NORMALIZE_STYLE: () => NORMALIZE_STYLE,
  OPEN_BLOCK: () => OPEN_BLOCK,
  POP_SCOPE_ID: () => POP_SCOPE_ID,
  PUSH_SCOPE_ID: () => PUSH_SCOPE_ID,
  RENDER_LIST: () => RENDER_LIST,
  RENDER_SLOT: () => RENDER_SLOT,
  RESOLVE_COMPONENT: () => RESOLVE_COMPONENT,
  RESOLVE_DIRECTIVE: () => RESOLVE_DIRECTIVE,
  RESOLVE_DYNAMIC_COMPONENT: () => RESOLVE_DYNAMIC_COMPONENT,
  RESOLVE_FILTER: () => RESOLVE_FILTER,
  SET_BLOCK_TRACKING: () => SET_BLOCK_TRACKING,
  SUSPENSE: () => SUSPENSE,
  TELEPORT: () => TELEPORT,
  TO_DISPLAY_STRING: () => TO_DISPLAY_STRING,
  TO_HANDLERS: () => TO_HANDLERS,
  TO_HANDLER_KEY: () => TO_HANDLER_KEY,
  TRANSITION: () => TRANSITION,
  TRANSITION_GROUP: () => TRANSITION_GROUP,
  TS_NODE_TYPES: () => TS_NODE_TYPES,
  UNREF: () => UNREF,
  V_MODEL_CHECKBOX: () => V_MODEL_CHECKBOX,
  V_MODEL_DYNAMIC: () => V_MODEL_DYNAMIC,
  V_MODEL_RADIO: () => V_MODEL_RADIO,
  V_MODEL_SELECT: () => V_MODEL_SELECT,
  V_MODEL_TEXT: () => V_MODEL_TEXT,
  V_ON_WITH_KEYS: () => V_ON_WITH_KEYS,
  V_ON_WITH_MODIFIERS: () => V_ON_WITH_MODIFIERS,
  V_SHOW: () => V_SHOW,
  WITH_CTX: () => WITH_CTX,
  WITH_DIRECTIVES: () => WITH_DIRECTIVES,
  WITH_MEMO: () => WITH_MEMO,
  advancePositionWithClone: () => advancePositionWithClone,
  advancePositionWithMutation: () => advancePositionWithMutation,
  assert: () => assert,
  baseCompile: () => baseCompile,
  baseParse: () => baseParse,
  buildDirectiveArgs: () => buildDirectiveArgs,
  buildProps: () => buildProps,
  buildSlots: () => buildSlots,
  checkCompatEnabled: () => checkCompatEnabled,
  compile: () => compile,
  convertToBlock: () => convertToBlock,
  createArrayExpression: () => createArrayExpression,
  createAssignmentExpression: () => createAssignmentExpression,
  createBlockStatement: () => createBlockStatement,
  createCacheExpression: () => createCacheExpression,
  createCallExpression: () => createCallExpression,
  createCompilerError: () => createCompilerError,
  createCompoundExpression: () => createCompoundExpression,
  createConditionalExpression: () => createConditionalExpression,
  createDOMCompilerError: () => createDOMCompilerError,
  createForLoopParams: () => createForLoopParams,
  createFunctionExpression: () => createFunctionExpression,
  createIfStatement: () => createIfStatement,
  createInterpolation: () => createInterpolation,
  createObjectExpression: () => createObjectExpression,
  createObjectProperty: () => createObjectProperty,
  createReturnStatement: () => createReturnStatement,
  createRoot: () => createRoot,
  createSequenceExpression: () => createSequenceExpression,
  createSimpleExpression: () => createSimpleExpression,
  createStructuralDirectiveTransform: () => createStructuralDirectiveTransform,
  createTemplateLiteral: () => createTemplateLiteral,
  createTransformContext: () => createTransformContext,
  createVNodeCall: () => createVNodeCall,
  extractIdentifiers: () => extractIdentifiers,
  findDir: () => findDir,
  findProp: () => findProp,
  generate: () => generate,
  generateCodeFrame: () => generateCodeFrame,
  getBaseTransformPreset: () => getBaseTransformPreset,
  getConstantType: () => getConstantType,
  getInnerRange: () => getInnerRange,
  getMemoedVNodeCall: () => getMemoedVNodeCall,
  getVNodeBlockHelper: () => getVNodeBlockHelper,
  getVNodeHelper: () => getVNodeHelper,
  hasDynamicKeyVBind: () => hasDynamicKeyVBind,
  hasScopeRef: () => hasScopeRef,
  helperNameMap: () => helperNameMap,
  injectProp: () => injectProp,
  isBuiltInType: () => isBuiltInType,
  isCoreComponent: () => isCoreComponent,
  isFunctionType: () => isFunctionType,
  isInDestructureAssignment: () => isInDestructureAssignment,
  isMemberExpression: () => isMemberExpression,
  isMemberExpressionBrowser: () => isMemberExpressionBrowser,
  isMemberExpressionNode: () => isMemberExpressionNode,
  isReferencedIdentifier: () => isReferencedIdentifier,
  isSimpleIdentifier: () => isSimpleIdentifier,
  isSlotOutlet: () => isSlotOutlet,
  isStaticArgOf: () => isStaticArgOf,
  isStaticExp: () => isStaticExp,
  isStaticProperty: () => isStaticProperty,
  isStaticPropertyKey: () => isStaticPropertyKey,
  isTemplateNode: () => isTemplateNode,
  isText: () => isText$1,
  isVSlot: () => isVSlot,
  locStub: () => locStub,
  noopDirectiveTransform: () => noopDirectiveTransform,
  parse: () => parse,
  parserOptions: () => parserOptions,
  processExpression: () => processExpression,
  processFor: () => processFor,
  processIf: () => processIf,
  processSlotOutlet: () => processSlotOutlet,
  registerRuntimeHelpers: () => registerRuntimeHelpers,
  resolveComponentType: () => resolveComponentType,
  stringifyExpression: () => stringifyExpression,
  toValidAssetId: () => toValidAssetId,
  trackSlotScopes: () => trackSlotScopes,
  trackVForSlotScopes: () => trackVForSlotScopes,
  transform: () => transform,
  transformBind: () => transformBind,
  transformElement: () => transformElement,
  transformExpression: () => transformExpression,
  transformModel: () => transformModel,
  transformOn: () => transformOn,
  transformStyle: () => transformStyle,
  traverseNode: () => traverseNode,
  walkBlockDeclarations: () => walkBlockDeclarations,
  walkFunctionParams: () => walkFunctionParams,
  walkIdentifiers: () => walkIdentifiers,
  warnDeprecation: () => warnDeprecation
});
function decodeHtmlBrowser(raw, asAttr = false) {
  if (!decoder) {
    decoder = document.createElement("div");
  }
  if (asAttr) {
    decoder.innerHTML = `<div foo="${raw.replace(/"/g, "&quot;")}">`;
    return decoder.children[0].getAttribute("foo");
  } else {
    decoder.innerHTML = raw;
    return decoder.textContent;
  }
}
function createDOMCompilerError(code, loc) {
  return createCompilerError(
    code,
    loc,
    true ? DOMErrorMessages : void 0
  );
}
function hasMultipleChildren(node) {
  const children = node.children = node.children.filter(
    (c) => c.type !== 3 && !(c.type === 2 && !c.content.trim())
  );
  const child = children[0];
  return children.length !== 1 || child.type === 11 || child.type === 9 && child.branches.some(hasMultipleChildren);
}
function compile(template, options = {}) {
  return baseCompile(
    template,
    extend({}, parserOptions, options, {
      nodeTransforms: [
        // ignore <script> and <tag>
        // this is not put inside DOMNodeTransforms because that list is used
        // by compiler-ssr to generate vnode fallback branches
        ignoreSideEffectTags,
        ...DOMNodeTransforms,
        ...options.nodeTransforms || []
      ],
      directiveTransforms: extend(
        {},
        DOMDirectiveTransforms,
        options.directiveTransforms || {}
      ),
      transformHoist: null
    })
  );
}
function parse(template, options = {}) {
  return baseParse(template, extend({}, parserOptions, options));
}
var V_MODEL_RADIO, V_MODEL_CHECKBOX, V_MODEL_TEXT, V_MODEL_SELECT, V_MODEL_DYNAMIC, V_ON_WITH_MODIFIERS, V_ON_WITH_KEYS, V_SHOW, TRANSITION, TRANSITION_GROUP, decoder, isRawTextContainer, parserOptions, transformStyle, parseInlineCSS, DOMErrorMessages, transformVHtml, transformVText, transformModel2, isEventOptionModifier, isNonKeyModifier, maybeKeyModifier, isKeyboardEvent, resolveModifiers, transformClick, transformOn2, transformShow, transformTransition, ignoreSideEffectTags, DOMNodeTransforms, DOMDirectiveTransforms;
var init_compiler_dom_esm_bundler = __esm({
  "node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js"() {
    init_compiler_core_esm_bundler();
    init_compiler_core_esm_bundler();
    init_shared_esm_bundler();
    V_MODEL_RADIO = Symbol(true ? `vModelRadio` : ``);
    V_MODEL_CHECKBOX = Symbol(true ? `vModelCheckbox` : ``);
    V_MODEL_TEXT = Symbol(true ? `vModelText` : ``);
    V_MODEL_SELECT = Symbol(true ? `vModelSelect` : ``);
    V_MODEL_DYNAMIC = Symbol(true ? `vModelDynamic` : ``);
    V_ON_WITH_MODIFIERS = Symbol(true ? `vOnModifiersGuard` : ``);
    V_ON_WITH_KEYS = Symbol(true ? `vOnKeysGuard` : ``);
    V_SHOW = Symbol(true ? `vShow` : ``);
    TRANSITION = Symbol(true ? `Transition` : ``);
    TRANSITION_GROUP = Symbol(true ? `TransitionGroup` : ``);
    registerRuntimeHelpers({
      [V_MODEL_RADIO]: `vModelRadio`,
      [V_MODEL_CHECKBOX]: `vModelCheckbox`,
      [V_MODEL_TEXT]: `vModelText`,
      [V_MODEL_SELECT]: `vModelSelect`,
      [V_MODEL_DYNAMIC]: `vModelDynamic`,
      [V_ON_WITH_MODIFIERS]: `withModifiers`,
      [V_ON_WITH_KEYS]: `withKeys`,
      [V_SHOW]: `vShow`,
      [TRANSITION]: `Transition`,
      [TRANSITION_GROUP]: `TransitionGroup`
    });
    isRawTextContainer = makeMap(
      "style,iframe,script,noscript",
      true
    );
    parserOptions = {
      isVoidTag,
      isNativeTag: (tag) => isHTMLTag(tag) || isSVGTag(tag),
      isPreTag: (tag) => tag === "pre",
      decodeEntities: decodeHtmlBrowser,
      isBuiltInComponent: (tag) => {
        if (isBuiltInType(tag, `Transition`)) {
          return TRANSITION;
        } else if (isBuiltInType(tag, `TransitionGroup`)) {
          return TRANSITION_GROUP;
        }
      },
      // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
      getNamespace(tag, parent) {
        let ns = parent ? parent.ns : 0;
        if (parent && ns === 2) {
          if (parent.tag === "annotation-xml") {
            if (tag === "svg") {
              return 1;
            }
            if (parent.props.some(
              (a) => a.type === 6 && a.name === "encoding" && a.value != null && (a.value.content === "text/html" || a.value.content === "application/xhtml+xml")
            )) {
              ns = 0;
            }
          } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== "mglyph" && tag !== "malignmark") {
            ns = 0;
          }
        } else if (parent && ns === 1) {
          if (parent.tag === "foreignObject" || parent.tag === "desc" || parent.tag === "title") {
            ns = 0;
          }
        }
        if (ns === 0) {
          if (tag === "svg") {
            return 1;
          }
          if (tag === "math") {
            return 2;
          }
        }
        return ns;
      },
      // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
      getTextMode({ tag, ns }) {
        if (ns === 0) {
          if (tag === "textarea" || tag === "title") {
            return 1;
          }
          if (isRawTextContainer(tag)) {
            return 2;
          }
        }
        return 0;
      }
    };
    transformStyle = (node) => {
      if (node.type === 1) {
        node.props.forEach((p, i) => {
          if (p.type === 6 && p.name === "style" && p.value) {
            node.props[i] = {
              type: 7,
              name: `bind`,
              arg: createSimpleExpression(`style`, true, p.loc),
              exp: parseInlineCSS(p.value.content, p.loc),
              modifiers: [],
              loc: p.loc
            };
          }
        });
      }
    };
    parseInlineCSS = (cssText, loc) => {
      const normalized = parseStringStyle(cssText);
      return createSimpleExpression(
        JSON.stringify(normalized),
        false,
        loc,
        3
      );
    };
    DOMErrorMessages = {
      [53]: `v-html is missing expression.`,
      [54]: `v-html will override element children.`,
      [55]: `v-text is missing expression.`,
      [56]: `v-text will override element children.`,
      [57]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
      [58]: `v-model argument is not supported on plain elements.`,
      [59]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
      [60]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
      [61]: `v-show is missing expression.`,
      [62]: `<Transition> expects exactly one child element or component.`,
      [63]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
    };
    transformVHtml = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
        context.onError(
          createDOMCompilerError(53, loc)
        );
      }
      if (node.children.length) {
        context.onError(
          createDOMCompilerError(54, loc)
        );
        node.children.length = 0;
      }
      return {
        props: [
          createObjectProperty(
            createSimpleExpression(`innerHTML`, true, loc),
            exp || createSimpleExpression("", true)
          )
        ]
      };
    };
    transformVText = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
        context.onError(
          createDOMCompilerError(55, loc)
        );
      }
      if (node.children.length) {
        context.onError(
          createDOMCompilerError(56, loc)
        );
        node.children.length = 0;
      }
      return {
        props: [
          createObjectProperty(
            createSimpleExpression(`textContent`, true),
            exp ? getConstantType(exp, context) > 0 ? exp : createCallExpression(
              context.helperString(TO_DISPLAY_STRING),
              [exp],
              loc
            ) : createSimpleExpression("", true)
          )
        ]
      };
    };
    transformModel2 = (dir, node, context) => {
      const baseResult = transformModel(dir, node, context);
      if (!baseResult.props.length || node.tagType === 1) {
        return baseResult;
      }
      if (dir.arg) {
        context.onError(
          createDOMCompilerError(
            58,
            dir.arg.loc
          )
        );
      }
      function checkDuplicatedValue() {
        const value = findProp(node, "value");
        if (value) {
          context.onError(
            createDOMCompilerError(
              60,
              value.loc
            )
          );
        }
      }
      const { tag } = node;
      const isCustomElement = context.isCustomElement(tag);
      if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
        let directiveToUse = V_MODEL_TEXT;
        let isInvalidType = false;
        if (tag === "input" || isCustomElement) {
          const type = findProp(node, `type`);
          if (type) {
            if (type.type === 7) {
              directiveToUse = V_MODEL_DYNAMIC;
            } else if (type.value) {
              switch (type.value.content) {
                case "radio":
                  directiveToUse = V_MODEL_RADIO;
                  break;
                case "checkbox":
                  directiveToUse = V_MODEL_CHECKBOX;
                  break;
                case "file":
                  isInvalidType = true;
                  context.onError(
                    createDOMCompilerError(
                      59,
                      dir.loc
                    )
                  );
                  break;
                default:
                  checkDuplicatedValue();
                  break;
              }
            }
          } else if (hasDynamicKeyVBind(node)) {
            directiveToUse = V_MODEL_DYNAMIC;
          } else {
            checkDuplicatedValue();
          }
        } else if (tag === "select") {
          directiveToUse = V_MODEL_SELECT;
        } else {
          checkDuplicatedValue();
        }
        if (!isInvalidType) {
          baseResult.needRuntime = context.helper(directiveToUse);
        }
      } else {
        context.onError(
          createDOMCompilerError(
            57,
            dir.loc
          )
        );
      }
      baseResult.props = baseResult.props.filter(
        (p) => !(p.key.type === 4 && p.key.content === "modelValue")
      );
      return baseResult;
    };
    isEventOptionModifier = makeMap(`passive,once,capture`);
    isNonKeyModifier = makeMap(
      // event propagation management
      `stop,prevent,self,ctrl,shift,alt,meta,exact,middle`
    );
    maybeKeyModifier = makeMap("left,right");
    isKeyboardEvent = makeMap(
      `onkeyup,onkeydown,onkeypress`,
      true
    );
    resolveModifiers = (key, modifiers, context, loc) => {
      const keyModifiers = [];
      const nonKeyModifiers = [];
      const eventOptionModifiers = [];
      for (let i = 0; i < modifiers.length; i++) {
        const modifier = modifiers[i];
        if (modifier === "native" && checkCompatEnabled(
          "COMPILER_V_ON_NATIVE",
          context,
          loc
        )) {
          eventOptionModifiers.push(modifier);
        } else if (isEventOptionModifier(modifier)) {
          eventOptionModifiers.push(modifier);
        } else {
          if (maybeKeyModifier(modifier)) {
            if (isStaticExp(key)) {
              if (isKeyboardEvent(key.content)) {
                keyModifiers.push(modifier);
              } else {
                nonKeyModifiers.push(modifier);
              }
            } else {
              keyModifiers.push(modifier);
              nonKeyModifiers.push(modifier);
            }
          } else {
            if (isNonKeyModifier(modifier)) {
              nonKeyModifiers.push(modifier);
            } else {
              keyModifiers.push(modifier);
            }
          }
        }
      }
      return {
        keyModifiers,
        nonKeyModifiers,
        eventOptionModifiers
      };
    };
    transformClick = (key, event) => {
      const isStaticClick = isStaticExp(key) && key.content.toLowerCase() === "onclick";
      return isStaticClick ? createSimpleExpression(event, true) : key.type !== 4 ? createCompoundExpression([
        `(`,
        key,
        `) === "onClick" ? "${event}" : (`,
        key,
        `)`
      ]) : key;
    };
    transformOn2 = (dir, node, context) => {
      return transformOn(dir, node, context, (baseResult) => {
        const { modifiers } = dir;
        if (!modifiers.length)
          return baseResult;
        let { key, value: handlerExp } = baseResult.props[0];
        const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);
        if (nonKeyModifiers.includes("right")) {
          key = transformClick(key, `onContextmenu`);
        }
        if (nonKeyModifiers.includes("middle")) {
          key = transformClick(key, `onMouseup`);
        }
        if (nonKeyModifiers.length) {
          handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
            handlerExp,
            JSON.stringify(nonKeyModifiers)
          ]);
        }
        if (keyModifiers.length && // if event name is dynamic, always wrap with keys guard
        (!isStaticExp(key) || isKeyboardEvent(key.content))) {
          handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [
            handlerExp,
            JSON.stringify(keyModifiers)
          ]);
        }
        if (eventOptionModifiers.length) {
          const modifierPostfix = eventOptionModifiers.map(capitalize).join("");
          key = isStaticExp(key) ? createSimpleExpression(`${key.content}${modifierPostfix}`, true) : createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
        }
        return {
          props: [createObjectProperty(key, handlerExp)]
        };
      });
    };
    transformShow = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
        context.onError(
          createDOMCompilerError(61, loc)
        );
      }
      return {
        props: [],
        needRuntime: context.helper(V_SHOW)
      };
    };
    transformTransition = (node, context) => {
      if (node.type === 1 && node.tagType === 1) {
        const component = context.isBuiltInComponent(node.tag);
        if (component === TRANSITION) {
          return () => {
            if (!node.children.length) {
              return;
            }
            if (hasMultipleChildren(node)) {
              context.onError(
                createDOMCompilerError(
                  62,
                  {
                    start: node.children[0].loc.start,
                    end: node.children[node.children.length - 1].loc.end,
                    source: ""
                  }
                )
              );
            }
            const child = node.children[0];
            if (child.type === 1) {
              for (const p of child.props) {
                if (p.type === 7 && p.name === "show") {
                  node.props.push({
                    type: 6,
                    name: "persisted",
                    value: void 0,
                    loc: node.loc
                  });
                }
              }
            }
          };
        }
      }
    };
    ignoreSideEffectTags = (node, context) => {
      if (node.type === 1 && node.tagType === 0 && (node.tag === "script" || node.tag === "style")) {
        context.onError(
          createDOMCompilerError(
            63,
            node.loc
          )
        );
        context.removeNode();
      }
    };
    DOMNodeTransforms = [
      transformStyle,
      ...true ? [transformTransition] : []
    ];
    DOMDirectiveTransforms = {
      cloak: noopDirectiveTransform,
      html: transformVHtml,
      text: transformVText,
      model: transformModel2,
      // override compiler-core
      on: transformOn2,
      // override compiler-core
      show: transformShow
    };
  }
});

// node_modules/vue/dist/vue.cjs.js
var require_vue_cjs = __commonJS({
  "node_modules/vue/dist/vue.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var compilerDom = (init_compiler_dom_esm_bundler(), __toCommonJS(compiler_dom_esm_bundler_exports));
    var runtimeDom = (init_runtime_dom_esm_bundler(), __toCommonJS(runtime_dom_esm_bundler_exports));
    var shared = (init_shared_esm_bundler(), __toCommonJS(shared_esm_bundler_exports));
    function _interopNamespaceDefault(e) {
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        for (var k in e) {
          n[k] = e[k];
        }
      }
      n.default = e;
      return Object.freeze(n);
    }
    var runtimeDom__namespace = _interopNamespaceDefault(runtimeDom);
    var compileCache = /* @__PURE__ */ Object.create(null);
    function compileToFunction(template, options) {
      if (!shared.isString(template)) {
        if (template.nodeType) {
          template = template.innerHTML;
        } else {
          runtimeDom.warn(`invalid template option: `, template);
          return shared.NOOP;
        }
      }
      const key = template;
      const cached = compileCache[key];
      if (cached) {
        return cached;
      }
      if (template[0] === "#") {
        const el = document.querySelector(template);
        if (!el) {
          runtimeDom.warn(`Template element not found or is empty: ${template}`);
        }
        template = el ? el.innerHTML : ``;
      }
      const opts = shared.extend(
        {
          hoistStatic: true,
          onError,
          onWarn: (e) => onError(e, true)
        },
        options
      );
      if (!opts.isCustomElement && typeof customElements !== "undefined") {
        opts.isCustomElement = (tag) => !!customElements.get(tag);
      }
      const { code } = compilerDom.compile(template, opts);
      function onError(err, asWarning = false) {
        const message = asWarning ? err.message : `Template compilation error: ${err.message}`;
        const codeFrame = err.loc && shared.generateCodeFrame(
          template,
          err.loc.start.offset,
          err.loc.end.offset
        );
        runtimeDom.warn(codeFrame ? `${message}
${codeFrame}` : message);
      }
      const render = new Function("Vue", code)(runtimeDom__namespace);
      render._rc = true;
      return compileCache[key] = render;
    }
    runtimeDom.registerRuntimeCompiler(compileToFunction);
    exports.compile = compileToFunction;
    Object.keys(runtimeDom).forEach(function(k) {
      if (k !== "default" && !exports.hasOwnProperty(k))
        exports[k] = runtimeDom[k];
    });
  }
});

// node_modules/vue/index.js
var require_vue = __commonJS({
  "node_modules/vue/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_vue_cjs();
    }
  }
});

// node_modules/buntpapier/dist/buntpapier.common.js
var require_buntpapier_common = __commonJS({
  "node_modules/buntpapier/dist/buntpapier.common.js"(exports, module) {
    module.exports = /******/
    function(modules) {
      var installedModules = {};
      function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) {
          return installedModules[moduleId].exports;
        }
        var module2 = installedModules[moduleId] = {
          /******/
          i: moduleId,
          /******/
          l: false,
          /******/
          exports: {}
          /******/
        };
        modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
        module2.l = true;
        return module2.exports;
      }
      __webpack_require__.m = modules;
      __webpack_require__.c = installedModules;
      __webpack_require__.d = function(exports2, name, getter) {
        if (!__webpack_require__.o(exports2, name)) {
          Object.defineProperty(exports2, name, { enumerable: true, get: getter });
        }
      };
      __webpack_require__.r = function(exports2) {
        if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
          Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
        }
        Object.defineProperty(exports2, "__esModule", { value: true });
      };
      __webpack_require__.t = function(value, mode) {
        if (mode & 1)
          value = __webpack_require__(value);
        if (mode & 8)
          return value;
        if (mode & 4 && typeof value === "object" && value && value.__esModule)
          return value;
        var ns = /* @__PURE__ */ Object.create(null);
        __webpack_require__.r(ns);
        Object.defineProperty(ns, "default", { enumerable: true, value });
        if (mode & 2 && typeof value != "string")
          for (var key in value)
            __webpack_require__.d(ns, key, (function(key2) {
              return value[key2];
            }).bind(null, key));
        return ns;
      };
      __webpack_require__.n = function(module2) {
        var getter = module2 && module2.__esModule ? (
          /******/
          function getDefault() {
            return module2["default"];
          }
        ) : (
          /******/
          function getModuleExports() {
            return module2;
          }
        );
        __webpack_require__.d(getter, "a", getter);
        return getter;
      };
      __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      __webpack_require__.p = "";
      return __webpack_require__(__webpack_require__.s = "fb15");
    }({
      /***/
      "2e39": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          function fuzzysearch(needle, haystack) {
            var tlen = haystack.length;
            var qlen = needle.length;
            if (qlen > tlen) {
              return false;
            }
            if (qlen === tlen) {
              return needle === haystack;
            }
            outer:
              for (var i = 0, j = 0; i < qlen; i++) {
                var nch = needle.charCodeAt(i);
                while (j < tlen) {
                  if (haystack.charCodeAt(j++) === nch) {
                    continue outer;
                  }
                }
                return false;
              }
            return true;
          }
          module2.exports = fuzzysearch;
        }
      ),
      /***/
      "6dd8": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          (function(global) {
            var MapShim = function() {
              if (typeof Map !== "undefined") {
                return Map;
              }
              function getIndex(arr, key) {
                var result = -1;
                arr.some(function(entry, index2) {
                  if (entry[0] === key) {
                    result = index2;
                    return true;
                  }
                  return false;
                });
                return result;
              }
              return (
                /** @class */
                function() {
                  function class_1() {
                    this.__entries__ = [];
                  }
                  Object.defineProperty(class_1.prototype, "size", {
                    /**
                     * @returns {boolean}
                     */
                    get: function() {
                      return this.__entries__.length;
                    },
                    enumerable: true,
                    configurable: true
                  });
                  class_1.prototype.get = function(key) {
                    var index2 = getIndex(this.__entries__, key);
                    var entry = this.__entries__[index2];
                    return entry && entry[1];
                  };
                  class_1.prototype.set = function(key, value) {
                    var index2 = getIndex(this.__entries__, key);
                    if (~index2) {
                      this.__entries__[index2][1] = value;
                    } else {
                      this.__entries__.push([key, value]);
                    }
                  };
                  class_1.prototype.delete = function(key) {
                    var entries = this.__entries__;
                    var index2 = getIndex(entries, key);
                    if (~index2) {
                      entries.splice(index2, 1);
                    }
                  };
                  class_1.prototype.has = function(key) {
                    return !!~getIndex(this.__entries__, key);
                  };
                  class_1.prototype.clear = function() {
                    this.__entries__.splice(0);
                  };
                  class_1.prototype.forEach = function(callback, ctx) {
                    if (ctx === void 0) {
                      ctx = null;
                    }
                    for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                      var entry = _a[_i];
                      callback.call(ctx, entry[1], entry[0]);
                    }
                  };
                  return class_1;
                }()
              );
            }();
            var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
            var global$1 = function() {
              if (typeof global !== "undefined" && global.Math === Math) {
                return global;
              }
              if (typeof self !== "undefined" && self.Math === Math) {
                return self;
              }
              if (typeof window !== "undefined" && window.Math === Math) {
                return window;
              }
              return Function("return this")();
            }();
            var requestAnimationFrame$1 = function() {
              if (typeof requestAnimationFrame === "function") {
                return requestAnimationFrame.bind(global$1);
              }
              return function(callback) {
                return setTimeout(function() {
                  return callback(Date.now());
                }, 1e3 / 60);
              };
            }();
            var trailingTimeout = 2;
            function throttle(callback, delay) {
              var leadingCall = false, trailingCall = false, lastCallTime = 0;
              function resolvePending() {
                if (leadingCall) {
                  leadingCall = false;
                  callback();
                }
                if (trailingCall) {
                  proxy();
                }
              }
              function timeoutCallback() {
                requestAnimationFrame$1(resolvePending);
              }
              function proxy() {
                var timeStamp = Date.now();
                if (leadingCall) {
                  if (timeStamp - lastCallTime < trailingTimeout) {
                    return;
                  }
                  trailingCall = true;
                } else {
                  leadingCall = true;
                  trailingCall = false;
                  setTimeout(timeoutCallback, delay);
                }
                lastCallTime = timeStamp;
              }
              return proxy;
            }
            var REFRESH_DELAY = 20;
            var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
            var mutationObserverSupported = typeof MutationObserver !== "undefined";
            var ResizeObserverController = (
              /** @class */
              function() {
                function ResizeObserverController2() {
                  this.connected_ = false;
                  this.mutationEventsAdded_ = false;
                  this.mutationsObserver_ = null;
                  this.observers_ = [];
                  this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
                  this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
                }
                ResizeObserverController2.prototype.addObserver = function(observer) {
                  if (!~this.observers_.indexOf(observer)) {
                    this.observers_.push(observer);
                  }
                  if (!this.connected_) {
                    this.connect_();
                  }
                };
                ResizeObserverController2.prototype.removeObserver = function(observer) {
                  var observers2 = this.observers_;
                  var index2 = observers2.indexOf(observer);
                  if (~index2) {
                    observers2.splice(index2, 1);
                  }
                  if (!observers2.length && this.connected_) {
                    this.disconnect_();
                  }
                };
                ResizeObserverController2.prototype.refresh = function() {
                  var changesDetected = this.updateObservers_();
                  if (changesDetected) {
                    this.refresh();
                  }
                };
                ResizeObserverController2.prototype.updateObservers_ = function() {
                  var activeObservers = this.observers_.filter(function(observer) {
                    return observer.gatherActive(), observer.hasActive();
                  });
                  activeObservers.forEach(function(observer) {
                    return observer.broadcastActive();
                  });
                  return activeObservers.length > 0;
                };
                ResizeObserverController2.prototype.connect_ = function() {
                  if (!isBrowser || this.connected_) {
                    return;
                  }
                  document.addEventListener("transitionend", this.onTransitionEnd_);
                  window.addEventListener("resize", this.refresh);
                  if (mutationObserverSupported) {
                    this.mutationsObserver_ = new MutationObserver(this.refresh);
                    this.mutationsObserver_.observe(document, {
                      attributes: true,
                      childList: true,
                      characterData: true,
                      subtree: true
                    });
                  } else {
                    document.addEventListener("DOMSubtreeModified", this.refresh);
                    this.mutationEventsAdded_ = true;
                  }
                  this.connected_ = true;
                };
                ResizeObserverController2.prototype.disconnect_ = function() {
                  if (!isBrowser || !this.connected_) {
                    return;
                  }
                  document.removeEventListener("transitionend", this.onTransitionEnd_);
                  window.removeEventListener("resize", this.refresh);
                  if (this.mutationsObserver_) {
                    this.mutationsObserver_.disconnect();
                  }
                  if (this.mutationEventsAdded_) {
                    document.removeEventListener("DOMSubtreeModified", this.refresh);
                  }
                  this.mutationsObserver_ = null;
                  this.mutationEventsAdded_ = false;
                  this.connected_ = false;
                };
                ResizeObserverController2.prototype.onTransitionEnd_ = function(_a) {
                  var _b = _a.propertyName, propertyName = _b === void 0 ? "" : _b;
                  var isReflowProperty = transitionKeys.some(function(key) {
                    return !!~propertyName.indexOf(key);
                  });
                  if (isReflowProperty) {
                    this.refresh();
                  }
                };
                ResizeObserverController2.getInstance = function() {
                  if (!this.instance_) {
                    this.instance_ = new ResizeObserverController2();
                  }
                  return this.instance_;
                };
                ResizeObserverController2.instance_ = null;
                return ResizeObserverController2;
              }()
            );
            var defineConfigurable = function(target, props) {
              for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
                var key = _a[_i];
                Object.defineProperty(target, key, {
                  value: props[key],
                  enumerable: false,
                  writable: false,
                  configurable: true
                });
              }
              return target;
            };
            var getWindowOf = function(target) {
              var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
              return ownerGlobal || global$1;
            };
            var emptyRect = createRectInit(0, 0, 0, 0);
            function toFloat(value) {
              return parseFloat(value) || 0;
            }
            function getBordersSize(styles) {
              var positions = [];
              for (var _i = 1; _i < arguments.length; _i++) {
                positions[_i - 1] = arguments[_i];
              }
              return positions.reduce(function(size, position) {
                var value = styles["border-" + position + "-width"];
                return size + toFloat(value);
              }, 0);
            }
            function getPaddings(styles) {
              var positions = ["top", "right", "bottom", "left"];
              var paddings = {};
              for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
                var position = positions_1[_i];
                var value = styles["padding-" + position];
                paddings[position] = toFloat(value);
              }
              return paddings;
            }
            function getSVGContentRect(target) {
              var bbox = target.getBBox();
              return createRectInit(0, 0, bbox.width, bbox.height);
            }
            function getHTMLElementContentRect(target) {
              var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
              if (!clientWidth && !clientHeight) {
                return emptyRect;
              }
              var styles = getWindowOf(target).getComputedStyle(target);
              var paddings = getPaddings(styles);
              var horizPad = paddings.left + paddings.right;
              var vertPad = paddings.top + paddings.bottom;
              var width = toFloat(styles.width), height = toFloat(styles.height);
              if (styles.boxSizing === "border-box") {
                if (Math.round(width + horizPad) !== clientWidth) {
                  width -= getBordersSize(styles, "left", "right") + horizPad;
                }
                if (Math.round(height + vertPad) !== clientHeight) {
                  height -= getBordersSize(styles, "top", "bottom") + vertPad;
                }
              }
              if (!isDocumentElement(target)) {
                var vertScrollbar = Math.round(width + horizPad) - clientWidth;
                var horizScrollbar = Math.round(height + vertPad) - clientHeight;
                if (Math.abs(vertScrollbar) !== 1) {
                  width -= vertScrollbar;
                }
                if (Math.abs(horizScrollbar) !== 1) {
                  height -= horizScrollbar;
                }
              }
              return createRectInit(paddings.left, paddings.top, width, height);
            }
            var isSVGGraphicsElement = function() {
              if (typeof SVGGraphicsElement !== "undefined") {
                return function(target) {
                  return target instanceof getWindowOf(target).SVGGraphicsElement;
                };
              }
              return function(target) {
                return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
              };
            }();
            function isDocumentElement(target) {
              return target === getWindowOf(target).document.documentElement;
            }
            function getContentRect(target) {
              if (!isBrowser) {
                return emptyRect;
              }
              if (isSVGGraphicsElement(target)) {
                return getSVGContentRect(target);
              }
              return getHTMLElementContentRect(target);
            }
            function createReadOnlyRect(_a) {
              var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
              var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
              var rect = Object.create(Constr.prototype);
              defineConfigurable(rect, {
                x,
                y,
                width,
                height,
                top: y,
                right: x + width,
                bottom: height + y,
                left: x
              });
              return rect;
            }
            function createRectInit(x, y, width, height) {
              return { x, y, width, height };
            }
            var ResizeObservation = (
              /** @class */
              function() {
                function ResizeObservation2(target) {
                  this.broadcastWidth = 0;
                  this.broadcastHeight = 0;
                  this.contentRect_ = createRectInit(0, 0, 0, 0);
                  this.target = target;
                }
                ResizeObservation2.prototype.isActive = function() {
                  var rect = getContentRect(this.target);
                  this.contentRect_ = rect;
                  return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
                };
                ResizeObservation2.prototype.broadcastRect = function() {
                  var rect = this.contentRect_;
                  this.broadcastWidth = rect.width;
                  this.broadcastHeight = rect.height;
                  return rect;
                };
                return ResizeObservation2;
              }()
            );
            var ResizeObserverEntry = (
              /** @class */
              function() {
                function ResizeObserverEntry2(target, rectInit) {
                  var contentRect = createReadOnlyRect(rectInit);
                  defineConfigurable(this, { target, contentRect });
                }
                return ResizeObserverEntry2;
              }()
            );
            var ResizeObserverSPI = (
              /** @class */
              function() {
                function ResizeObserverSPI2(callback, controller, callbackCtx) {
                  this.activeObservations_ = [];
                  this.observations_ = new MapShim();
                  if (typeof callback !== "function") {
                    throw new TypeError("The callback provided as parameter 1 is not a function.");
                  }
                  this.callback_ = callback;
                  this.controller_ = controller;
                  this.callbackCtx_ = callbackCtx;
                }
                ResizeObserverSPI2.prototype.observe = function(target) {
                  if (!arguments.length) {
                    throw new TypeError("1 argument required, but only 0 present.");
                  }
                  if (typeof Element === "undefined" || !(Element instanceof Object)) {
                    return;
                  }
                  if (!(target instanceof getWindowOf(target).Element)) {
                    throw new TypeError('parameter 1 is not of type "Element".');
                  }
                  var observations = this.observations_;
                  if (observations.has(target)) {
                    return;
                  }
                  observations.set(target, new ResizeObservation(target));
                  this.controller_.addObserver(this);
                  this.controller_.refresh();
                };
                ResizeObserverSPI2.prototype.unobserve = function(target) {
                  if (!arguments.length) {
                    throw new TypeError("1 argument required, but only 0 present.");
                  }
                  if (typeof Element === "undefined" || !(Element instanceof Object)) {
                    return;
                  }
                  if (!(target instanceof getWindowOf(target).Element)) {
                    throw new TypeError('parameter 1 is not of type "Element".');
                  }
                  var observations = this.observations_;
                  if (!observations.has(target)) {
                    return;
                  }
                  observations.delete(target);
                  if (!observations.size) {
                    this.controller_.removeObserver(this);
                  }
                };
                ResizeObserverSPI2.prototype.disconnect = function() {
                  this.clearActive();
                  this.observations_.clear();
                  this.controller_.removeObserver(this);
                };
                ResizeObserverSPI2.prototype.gatherActive = function() {
                  var _this = this;
                  this.clearActive();
                  this.observations_.forEach(function(observation) {
                    if (observation.isActive()) {
                      _this.activeObservations_.push(observation);
                    }
                  });
                };
                ResizeObserverSPI2.prototype.broadcastActive = function() {
                  if (!this.hasActive()) {
                    return;
                  }
                  var ctx = this.callbackCtx_;
                  var entries = this.activeObservations_.map(function(observation) {
                    return new ResizeObserverEntry(observation.target, observation.broadcastRect());
                  });
                  this.callback_.call(ctx, entries, ctx);
                  this.clearActive();
                };
                ResizeObserverSPI2.prototype.clearActive = function() {
                  this.activeObservations_.splice(0);
                };
                ResizeObserverSPI2.prototype.hasActive = function() {
                  return this.activeObservations_.length > 0;
                };
                return ResizeObserverSPI2;
              }()
            );
            var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
            var ResizeObserver = (
              /** @class */
              function() {
                function ResizeObserver2(callback) {
                  if (!(this instanceof ResizeObserver2)) {
                    throw new TypeError("Cannot call a class as a function.");
                  }
                  if (!arguments.length) {
                    throw new TypeError("1 argument required, but only 0 present.");
                  }
                  var controller = ResizeObserverController.getInstance();
                  var observer = new ResizeObserverSPI(callback, controller, this);
                  observers.set(this, observer);
                }
                return ResizeObserver2;
              }()
            );
            [
              "observe",
              "unobserve",
              "disconnect"
            ].forEach(function(method) {
              ResizeObserver.prototype[method] = function() {
                var _a;
                return (_a = observers.get(this))[method].apply(_a, arguments);
              };
            });
            var index = function() {
              if (typeof global$1.ResizeObserver !== "undefined") {
                return global$1.ResizeObserver;
              }
              return ResizeObserver;
            }();
            __webpack_exports__["a"] = index;
          }).call(this, __webpack_require__("c8ba"));
        }
      ),
      /***/
      "8875": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
          (function(root, factory) {
            if (true) {
              !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function" ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports2, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            } else {
            }
          })(typeof self !== "undefined" ? self : this, function() {
            function getCurrentScript() {
              var descriptor = Object.getOwnPropertyDescriptor(document, "currentScript");
              if (!descriptor && "currentScript" in document && document.currentScript) {
                return document.currentScript;
              }
              if (descriptor && descriptor.get !== getCurrentScript && document.currentScript) {
                return document.currentScript;
              }
              try {
                throw new Error();
              } catch (err) {
                var ieStackRegExp = /.*at [^(]*\((.*):(.+):(.+)\)$/ig, ffStackRegExp = /@([^@]*):(\d+):(\d+)\s*$/ig, stackDetails = ieStackRegExp.exec(err.stack) || ffStackRegExp.exec(err.stack), scriptLocation = stackDetails && stackDetails[1] || false, line = stackDetails && stackDetails[2] || false, currentLocation = document.location.href.replace(document.location.hash, ""), pageSource, inlineScriptSourceRegExp, inlineScriptSource, scripts = document.getElementsByTagName("script");
                if (scriptLocation === currentLocation) {
                  pageSource = document.documentElement.outerHTML;
                  inlineScriptSourceRegExp = new RegExp("(?:[^\\n]+?\\n){0," + (line - 2) + "}[^<]*<script>([\\d\\D]*?)<\\/script>[\\d\\D]*", "i");
                  inlineScriptSource = pageSource.replace(inlineScriptSourceRegExp, "$1").trim();
                }
                for (var i = 0; i < scripts.length; i++) {
                  if (scripts[i].readyState === "interactive") {
                    return scripts[i];
                  }
                  if (scripts[i].src === scriptLocation) {
                    return scripts[i];
                  }
                  if (scriptLocation === currentLocation && scripts[i].innerHTML && scripts[i].innerHTML.trim() === inlineScriptSource) {
                    return scripts[i];
                  }
                }
                return null;
              }
            }
            ;
            return getCurrentScript;
          });
        }
      ),
      /***/
      "8bbf": (
        /***/
        function(module2, exports2) {
          module2.exports = require_vue();
        }
      ),
      /***/
      "c8ba": (
        /***/
        function(module2, exports2) {
          var g;
          g = function() {
            return this;
          }();
          try {
            g = g || new Function("return this")();
          } catch (e) {
            if (typeof window === "object")
              g = window;
          }
          module2.exports = g;
        }
      ),
      /***/
      "f0bd": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          (function(global) {
            var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && typeof navigator !== "undefined";
            var timeoutDuration = function() {
              var longerTimeoutBrowsers = ["Edge", "Trident", "Firefox"];
              for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
                if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
                  return 1;
                }
              }
              return 0;
            }();
            function microtaskDebounce(fn) {
              var called = false;
              return function() {
                if (called) {
                  return;
                }
                called = true;
                window.Promise.resolve().then(function() {
                  called = false;
                  fn();
                });
              };
            }
            function taskDebounce(fn) {
              var scheduled = false;
              return function() {
                if (!scheduled) {
                  scheduled = true;
                  setTimeout(function() {
                    scheduled = false;
                    fn();
                  }, timeoutDuration);
                }
              };
            }
            var supportsMicroTasks = isBrowser && window.Promise;
            var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;
            function isFunction(functionToCheck) {
              var getType = {};
              return functionToCheck && getType.toString.call(functionToCheck) === "[object Function]";
            }
            function getStyleComputedProperty(element, property) {
              if (element.nodeType !== 1) {
                return [];
              }
              var window2 = element.ownerDocument.defaultView;
              var css = window2.getComputedStyle(element, null);
              return property ? css[property] : css;
            }
            function getParentNode(element) {
              if (element.nodeName === "HTML") {
                return element;
              }
              return element.parentNode || element.host;
            }
            function getScrollParent(element) {
              if (!element) {
                return document.body;
              }
              switch (element.nodeName) {
                case "HTML":
                case "BODY":
                  return element.ownerDocument.body;
                case "#document":
                  return element.body;
              }
              var _getStyleComputedProp = getStyleComputedProperty(element), overflow = _getStyleComputedProp.overflow, overflowX = _getStyleComputedProp.overflowX, overflowY = _getStyleComputedProp.overflowY;
              if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
                return element;
              }
              return getScrollParent(getParentNode(element));
            }
            function getReferenceNode(reference) {
              return reference && reference.referenceNode ? reference.referenceNode : reference;
            }
            var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
            var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);
            function isIE(version) {
              if (version === 11) {
                return isIE11;
              }
              if (version === 10) {
                return isIE10;
              }
              return isIE11 || isIE10;
            }
            function getOffsetParent(element) {
              if (!element) {
                return document.documentElement;
              }
              var noOffsetParent = isIE(10) ? document.body : null;
              var offsetParent = element.offsetParent || null;
              while (offsetParent === noOffsetParent && element.nextElementSibling) {
                offsetParent = (element = element.nextElementSibling).offsetParent;
              }
              var nodeName = offsetParent && offsetParent.nodeName;
              if (!nodeName || nodeName === "BODY" || nodeName === "HTML") {
                return element ? element.ownerDocument.documentElement : document.documentElement;
              }
              if (["TH", "TD", "TABLE"].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, "position") === "static") {
                return getOffsetParent(offsetParent);
              }
              return offsetParent;
            }
            function isOffsetContainer(element) {
              var nodeName = element.nodeName;
              if (nodeName === "BODY") {
                return false;
              }
              return nodeName === "HTML" || getOffsetParent(element.firstElementChild) === element;
            }
            function getRoot(node) {
              if (node.parentNode !== null) {
                return getRoot(node.parentNode);
              }
              return node;
            }
            function findCommonOffsetParent(element1, element2) {
              if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
                return document.documentElement;
              }
              var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
              var start = order ? element1 : element2;
              var end = order ? element2 : element1;
              var range = document.createRange();
              range.setStart(start, 0);
              range.setEnd(end, 0);
              var commonAncestorContainer = range.commonAncestorContainer;
              if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
                if (isOffsetContainer(commonAncestorContainer)) {
                  return commonAncestorContainer;
                }
                return getOffsetParent(commonAncestorContainer);
              }
              var element1root = getRoot(element1);
              if (element1root.host) {
                return findCommonOffsetParent(element1root.host, element2);
              } else {
                return findCommonOffsetParent(element1, getRoot(element2).host);
              }
            }
            function getScroll(element) {
              var side = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "top";
              var upperSide = side === "top" ? "scrollTop" : "scrollLeft";
              var nodeName = element.nodeName;
              if (nodeName === "BODY" || nodeName === "HTML") {
                var html = element.ownerDocument.documentElement;
                var scrollingElement = element.ownerDocument.scrollingElement || html;
                return scrollingElement[upperSide];
              }
              return element[upperSide];
            }
            function includeScroll(rect, element) {
              var subtract = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              var scrollTop = getScroll(element, "top");
              var scrollLeft = getScroll(element, "left");
              var modifier = subtract ? -1 : 1;
              rect.top += scrollTop * modifier;
              rect.bottom += scrollTop * modifier;
              rect.left += scrollLeft * modifier;
              rect.right += scrollLeft * modifier;
              return rect;
            }
            function getBordersSize(styles, axis) {
              var sideA = axis === "x" ? "Left" : "Top";
              var sideB = sideA === "Left" ? "Right" : "Bottom";
              return parseFloat(styles["border" + sideA + "Width"]) + parseFloat(styles["border" + sideB + "Width"]);
            }
            function getSize(axis, body, html, computedStyle) {
              return Math.max(body["offset" + axis], body["scroll" + axis], html["client" + axis], html["offset" + axis], html["scroll" + axis], isIE(10) ? parseInt(html["offset" + axis]) + parseInt(computedStyle["margin" + (axis === "Height" ? "Top" : "Left")]) + parseInt(computedStyle["margin" + (axis === "Height" ? "Bottom" : "Right")]) : 0);
            }
            function getWindowSizes(document2) {
              var body = document2.body;
              var html = document2.documentElement;
              var computedStyle = isIE(10) && getComputedStyle(html);
              return {
                height: getSize("Height", body, html, computedStyle),
                width: getSize("Width", body, html, computedStyle)
              };
            }
            var classCallCheck = function(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            };
            var createClass = function() {
              function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var defineProperty = function(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, {
                  value,
                  enumerable: true,
                  configurable: true,
                  writable: true
                });
              } else {
                obj[key] = value;
              }
              return obj;
            };
            var _extends = Object.assign || function(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            };
            function getClientRect(offsets) {
              return _extends({}, offsets, {
                right: offsets.left + offsets.width,
                bottom: offsets.top + offsets.height
              });
            }
            function getBoundingClientRect(element) {
              var rect = {};
              try {
                if (isIE(10)) {
                  rect = element.getBoundingClientRect();
                  var scrollTop = getScroll(element, "top");
                  var scrollLeft = getScroll(element, "left");
                  rect.top += scrollTop;
                  rect.left += scrollLeft;
                  rect.bottom += scrollTop;
                  rect.right += scrollLeft;
                } else {
                  rect = element.getBoundingClientRect();
                }
              } catch (e) {
              }
              var result = {
                left: rect.left,
                top: rect.top,
                width: rect.right - rect.left,
                height: rect.bottom - rect.top
              };
              var sizes = element.nodeName === "HTML" ? getWindowSizes(element.ownerDocument) : {};
              var width = sizes.width || element.clientWidth || result.width;
              var height = sizes.height || element.clientHeight || result.height;
              var horizScrollbar = element.offsetWidth - width;
              var vertScrollbar = element.offsetHeight - height;
              if (horizScrollbar || vertScrollbar) {
                var styles = getStyleComputedProperty(element);
                horizScrollbar -= getBordersSize(styles, "x");
                vertScrollbar -= getBordersSize(styles, "y");
                result.width -= horizScrollbar;
                result.height -= vertScrollbar;
              }
              return getClientRect(result);
            }
            function getOffsetRectRelativeToArbitraryNode(children, parent) {
              var fixedPosition = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              var isIE102 = isIE(10);
              var isHTML = parent.nodeName === "HTML";
              var childrenRect = getBoundingClientRect(children);
              var parentRect = getBoundingClientRect(parent);
              var scrollParent = getScrollParent(children);
              var styles = getStyleComputedProperty(parent);
              var borderTopWidth = parseFloat(styles.borderTopWidth);
              var borderLeftWidth = parseFloat(styles.borderLeftWidth);
              if (fixedPosition && isHTML) {
                parentRect.top = Math.max(parentRect.top, 0);
                parentRect.left = Math.max(parentRect.left, 0);
              }
              var offsets = getClientRect({
                top: childrenRect.top - parentRect.top - borderTopWidth,
                left: childrenRect.left - parentRect.left - borderLeftWidth,
                width: childrenRect.width,
                height: childrenRect.height
              });
              offsets.marginTop = 0;
              offsets.marginLeft = 0;
              if (!isIE102 && isHTML) {
                var marginTop = parseFloat(styles.marginTop);
                var marginLeft = parseFloat(styles.marginLeft);
                offsets.top -= borderTopWidth - marginTop;
                offsets.bottom -= borderTopWidth - marginTop;
                offsets.left -= borderLeftWidth - marginLeft;
                offsets.right -= borderLeftWidth - marginLeft;
                offsets.marginTop = marginTop;
                offsets.marginLeft = marginLeft;
              }
              if (isIE102 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== "BODY") {
                offsets = includeScroll(offsets, parent);
              }
              return offsets;
            }
            function getViewportOffsetRectRelativeToArtbitraryNode(element) {
              var excludeScroll = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              var html = element.ownerDocument.documentElement;
              var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
              var width = Math.max(html.clientWidth, window.innerWidth || 0);
              var height = Math.max(html.clientHeight, window.innerHeight || 0);
              var scrollTop = !excludeScroll ? getScroll(html) : 0;
              var scrollLeft = !excludeScroll ? getScroll(html, "left") : 0;
              var offset2 = {
                top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
                left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
                width,
                height
              };
              return getClientRect(offset2);
            }
            function isFixed(element) {
              var nodeName = element.nodeName;
              if (nodeName === "BODY" || nodeName === "HTML") {
                return false;
              }
              if (getStyleComputedProperty(element, "position") === "fixed") {
                return true;
              }
              var parentNode = getParentNode(element);
              if (!parentNode) {
                return false;
              }
              return isFixed(parentNode);
            }
            function getFixedPositionOffsetParent(element) {
              if (!element || !element.parentElement || isIE()) {
                return document.documentElement;
              }
              var el = element.parentElement;
              while (el && getStyleComputedProperty(el, "transform") === "none") {
                el = el.parentElement;
              }
              return el || document.documentElement;
            }
            function getBoundaries(popper, reference, padding, boundariesElement) {
              var fixedPosition = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
              var boundaries = { top: 0, left: 0 };
              var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
              if (boundariesElement === "viewport") {
                boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
              } else {
                var boundariesNode = void 0;
                if (boundariesElement === "scrollParent") {
                  boundariesNode = getScrollParent(getParentNode(reference));
                  if (boundariesNode.nodeName === "BODY") {
                    boundariesNode = popper.ownerDocument.documentElement;
                  }
                } else if (boundariesElement === "window") {
                  boundariesNode = popper.ownerDocument.documentElement;
                } else {
                  boundariesNode = boundariesElement;
                }
                var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);
                if (boundariesNode.nodeName === "HTML" && !isFixed(offsetParent)) {
                  var _getWindowSizes = getWindowSizes(popper.ownerDocument), height = _getWindowSizes.height, width = _getWindowSizes.width;
                  boundaries.top += offsets.top - offsets.marginTop;
                  boundaries.bottom = height + offsets.top;
                  boundaries.left += offsets.left - offsets.marginLeft;
                  boundaries.right = width + offsets.left;
                } else {
                  boundaries = offsets;
                }
              }
              padding = padding || 0;
              var isPaddingNumber = typeof padding === "number";
              boundaries.left += isPaddingNumber ? padding : padding.left || 0;
              boundaries.top += isPaddingNumber ? padding : padding.top || 0;
              boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
              boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
              return boundaries;
            }
            function getArea(_ref) {
              var width = _ref.width, height = _ref.height;
              return width * height;
            }
            function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
              var padding = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0;
              if (placement.indexOf("auto") === -1) {
                return placement;
              }
              var boundaries = getBoundaries(popper, reference, padding, boundariesElement);
              var rects = {
                top: {
                  width: boundaries.width,
                  height: refRect.top - boundaries.top
                },
                right: {
                  width: boundaries.right - refRect.right,
                  height: boundaries.height
                },
                bottom: {
                  width: boundaries.width,
                  height: boundaries.bottom - refRect.bottom
                },
                left: {
                  width: refRect.left - boundaries.left,
                  height: boundaries.height
                }
              };
              var sortedAreas = Object.keys(rects).map(function(key) {
                return _extends({
                  key
                }, rects[key], {
                  area: getArea(rects[key])
                });
              }).sort(function(a, b) {
                return b.area - a.area;
              });
              var filteredAreas = sortedAreas.filter(function(_ref2) {
                var width = _ref2.width, height = _ref2.height;
                return width >= popper.clientWidth && height >= popper.clientHeight;
              });
              var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;
              var variation = placement.split("-")[1];
              return computedPlacement + (variation ? "-" + variation : "");
            }
            function getReferenceOffsets(state, popper, reference) {
              var fixedPosition = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
              var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
              return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
            }
            function getOuterSizes(element) {
              var window2 = element.ownerDocument.defaultView;
              var styles = window2.getComputedStyle(element);
              var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
              var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
              var result = {
                width: element.offsetWidth + y,
                height: element.offsetHeight + x
              };
              return result;
            }
            function getOppositePlacement(placement) {
              var hash = { left: "right", right: "left", bottom: "top", top: "bottom" };
              return placement.replace(/left|right|bottom|top/g, function(matched) {
                return hash[matched];
              });
            }
            function getPopperOffsets(popper, referenceOffsets, placement) {
              placement = placement.split("-")[0];
              var popperRect = getOuterSizes(popper);
              var popperOffsets = {
                width: popperRect.width,
                height: popperRect.height
              };
              var isHoriz = ["right", "left"].indexOf(placement) !== -1;
              var mainSide = isHoriz ? "top" : "left";
              var secondarySide = isHoriz ? "left" : "top";
              var measurement = isHoriz ? "height" : "width";
              var secondaryMeasurement = !isHoriz ? "height" : "width";
              popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
              if (placement === secondarySide) {
                popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
              } else {
                popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
              }
              return popperOffsets;
            }
            function find(arr, check) {
              if (Array.prototype.find) {
                return arr.find(check);
              }
              return arr.filter(check)[0];
            }
            function findIndex(arr, prop, value) {
              if (Array.prototype.findIndex) {
                return arr.findIndex(function(cur) {
                  return cur[prop] === value;
                });
              }
              var match = find(arr, function(obj) {
                return obj[prop] === value;
              });
              return arr.indexOf(match);
            }
            function runModifiers(modifiers2, data, ends) {
              var modifiersToRun = ends === void 0 ? modifiers2 : modifiers2.slice(0, findIndex(modifiers2, "name", ends));
              modifiersToRun.forEach(function(modifier) {
                if (modifier["function"]) {
                  console.warn("`modifier.function` is deprecated, use `modifier.fn`!");
                }
                var fn = modifier["function"] || modifier.fn;
                if (modifier.enabled && isFunction(fn)) {
                  data.offsets.popper = getClientRect(data.offsets.popper);
                  data.offsets.reference = getClientRect(data.offsets.reference);
                  data = fn(data, modifier);
                }
              });
              return data;
            }
            function update() {
              if (this.state.isDestroyed) {
                return;
              }
              var data = {
                instance: this,
                styles: {},
                arrowStyles: {},
                attributes: {},
                flipped: false,
                offsets: {}
              };
              data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);
              data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);
              data.originalPlacement = data.placement;
              data.positionFixed = this.options.positionFixed;
              data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
              data.offsets.popper.position = this.options.positionFixed ? "fixed" : "absolute";
              data = runModifiers(this.modifiers, data);
              if (!this.state.isCreated) {
                this.state.isCreated = true;
                this.options.onCreate(data);
              } else {
                this.options.onUpdate(data);
              }
            }
            function isModifierEnabled(modifiers2, modifierName) {
              return modifiers2.some(function(_ref) {
                var name = _ref.name, enabled = _ref.enabled;
                return enabled && name === modifierName;
              });
            }
            function getSupportedPropertyName(property) {
              var prefixes = [false, "ms", "Webkit", "Moz", "O"];
              var upperProp = property.charAt(0).toUpperCase() + property.slice(1);
              for (var i = 0; i < prefixes.length; i++) {
                var prefix = prefixes[i];
                var toCheck = prefix ? "" + prefix + upperProp : property;
                if (typeof document.body.style[toCheck] !== "undefined") {
                  return toCheck;
                }
              }
              return null;
            }
            function destroy() {
              this.state.isDestroyed = true;
              if (isModifierEnabled(this.modifiers, "applyStyle")) {
                this.popper.removeAttribute("x-placement");
                this.popper.style.position = "";
                this.popper.style.top = "";
                this.popper.style.left = "";
                this.popper.style.right = "";
                this.popper.style.bottom = "";
                this.popper.style.willChange = "";
                this.popper.style[getSupportedPropertyName("transform")] = "";
              }
              this.disableEventListeners();
              if (this.options.removeOnDestroy) {
                this.popper.parentNode.removeChild(this.popper);
              }
              return this;
            }
            function getWindow(element) {
              var ownerDocument = element.ownerDocument;
              return ownerDocument ? ownerDocument.defaultView : window;
            }
            function attachToScrollParents(scrollParent, event, callback, scrollParents) {
              var isBody = scrollParent.nodeName === "BODY";
              var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
              target.addEventListener(event, callback, { passive: true });
              if (!isBody) {
                attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
              }
              scrollParents.push(target);
            }
            function setupEventListeners(reference, options, state, updateBound) {
              state.updateBound = updateBound;
              getWindow(reference).addEventListener("resize", state.updateBound, { passive: true });
              var scrollElement = getScrollParent(reference);
              attachToScrollParents(scrollElement, "scroll", state.updateBound, state.scrollParents);
              state.scrollElement = scrollElement;
              state.eventsEnabled = true;
              return state;
            }
            function enableEventListeners() {
              if (!this.state.eventsEnabled) {
                this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
              }
            }
            function removeEventListeners(reference, state) {
              getWindow(reference).removeEventListener("resize", state.updateBound);
              state.scrollParents.forEach(function(target) {
                target.removeEventListener("scroll", state.updateBound);
              });
              state.updateBound = null;
              state.scrollParents = [];
              state.scrollElement = null;
              state.eventsEnabled = false;
              return state;
            }
            function disableEventListeners() {
              if (this.state.eventsEnabled) {
                cancelAnimationFrame(this.scheduleUpdate);
                this.state = removeEventListeners(this.reference, this.state);
              }
            }
            function isNumeric(n) {
              return n !== "" && !isNaN(parseFloat(n)) && isFinite(n);
            }
            function setStyles(element, styles) {
              Object.keys(styles).forEach(function(prop) {
                var unit = "";
                if (["width", "height", "top", "right", "bottom", "left"].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
                  unit = "px";
                }
                element.style[prop] = styles[prop] + unit;
              });
            }
            function setAttributes(element, attributes) {
              Object.keys(attributes).forEach(function(prop) {
                var value = attributes[prop];
                if (value !== false) {
                  element.setAttribute(prop, attributes[prop]);
                } else {
                  element.removeAttribute(prop);
                }
              });
            }
            function applyStyle(data) {
              setStyles(data.instance.popper, data.styles);
              setAttributes(data.instance.popper, data.attributes);
              if (data.arrowElement && Object.keys(data.arrowStyles).length) {
                setStyles(data.arrowElement, data.arrowStyles);
              }
              return data;
            }
            function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
              var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);
              var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
              popper.setAttribute("x-placement", placement);
              setStyles(popper, { position: options.positionFixed ? "fixed" : "absolute" });
              return options;
            }
            function getRoundedOffsets(data, shouldRound) {
              var _data$offsets = data.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
              var round = Math.round, floor = Math.floor;
              var noRound = function noRound2(v) {
                return v;
              };
              var referenceWidth = round(reference.width);
              var popperWidth = round(popper.width);
              var isVertical = ["left", "right"].indexOf(data.placement) !== -1;
              var isVariation = data.placement.indexOf("-") !== -1;
              var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
              var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;
              var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
              var verticalToInteger = !shouldRound ? noRound : round;
              return {
                left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
                top: verticalToInteger(popper.top),
                bottom: verticalToInteger(popper.bottom),
                right: horizontalToInteger(popper.right)
              };
            }
            var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);
            function computeStyle(data, options) {
              var x = options.x, y = options.y;
              var popper = data.offsets.popper;
              var legacyGpuAccelerationOption = find(data.instance.modifiers, function(modifier) {
                return modifier.name === "applyStyle";
              }).gpuAcceleration;
              if (legacyGpuAccelerationOption !== void 0) {
                console.warn("WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!");
              }
              var gpuAcceleration = legacyGpuAccelerationOption !== void 0 ? legacyGpuAccelerationOption : options.gpuAcceleration;
              var offsetParent = getOffsetParent(data.instance.popper);
              var offsetParentRect = getBoundingClientRect(offsetParent);
              var styles = {
                position: popper.position
              };
              var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);
              var sideA = x === "bottom" ? "top" : "bottom";
              var sideB = y === "right" ? "left" : "right";
              var prefixedProperty = getSupportedPropertyName("transform");
              var left = void 0, top = void 0;
              if (sideA === "bottom") {
                if (offsetParent.nodeName === "HTML") {
                  top = -offsetParent.clientHeight + offsets.bottom;
                } else {
                  top = -offsetParentRect.height + offsets.bottom;
                }
              } else {
                top = offsets.top;
              }
              if (sideB === "right") {
                if (offsetParent.nodeName === "HTML") {
                  left = -offsetParent.clientWidth + offsets.right;
                } else {
                  left = -offsetParentRect.width + offsets.right;
                }
              } else {
                left = offsets.left;
              }
              if (gpuAcceleration && prefixedProperty) {
                styles[prefixedProperty] = "translate3d(" + left + "px, " + top + "px, 0)";
                styles[sideA] = 0;
                styles[sideB] = 0;
                styles.willChange = "transform";
              } else {
                var invertTop = sideA === "bottom" ? -1 : 1;
                var invertLeft = sideB === "right" ? -1 : 1;
                styles[sideA] = top * invertTop;
                styles[sideB] = left * invertLeft;
                styles.willChange = sideA + ", " + sideB;
              }
              var attributes = {
                "x-placement": data.placement
              };
              data.attributes = _extends({}, attributes, data.attributes);
              data.styles = _extends({}, styles, data.styles);
              data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);
              return data;
            }
            function isModifierRequired(modifiers2, requestingName, requestedName) {
              var requesting = find(modifiers2, function(_ref) {
                var name = _ref.name;
                return name === requestingName;
              });
              var isRequired = !!requesting && modifiers2.some(function(modifier) {
                return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
              });
              if (!isRequired) {
                var _requesting = "`" + requestingName + "`";
                var requested = "`" + requestedName + "`";
                console.warn(requested + " modifier is required by " + _requesting + " modifier in order to work, be sure to include it before " + _requesting + "!");
              }
              return isRequired;
            }
            function arrow(data, options) {
              var _data$offsets$arrow;
              if (!isModifierRequired(data.instance.modifiers, "arrow", "keepTogether")) {
                return data;
              }
              var arrowElement = options.element;
              if (typeof arrowElement === "string") {
                arrowElement = data.instance.popper.querySelector(arrowElement);
                if (!arrowElement) {
                  return data;
                }
              } else {
                if (!data.instance.popper.contains(arrowElement)) {
                  console.warn("WARNING: `arrow.element` must be child of its popper element!");
                  return data;
                }
              }
              var placement = data.placement.split("-")[0];
              var _data$offsets = data.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
              var isVertical = ["left", "right"].indexOf(placement) !== -1;
              var len = isVertical ? "height" : "width";
              var sideCapitalized = isVertical ? "Top" : "Left";
              var side = sideCapitalized.toLowerCase();
              var altSide = isVertical ? "left" : "top";
              var opSide = isVertical ? "bottom" : "right";
              var arrowElementSize = getOuterSizes(arrowElement)[len];
              if (reference[opSide] - arrowElementSize < popper[side]) {
                data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
              }
              if (reference[side] + arrowElementSize > popper[opSide]) {
                data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
              }
              data.offsets.popper = getClientRect(data.offsets.popper);
              var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;
              var css = getStyleComputedProperty(data.instance.popper);
              var popperMarginSide = parseFloat(css["margin" + sideCapitalized]);
              var popperBorderSide = parseFloat(css["border" + sideCapitalized + "Width"]);
              var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;
              sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);
              data.arrowElement = arrowElement;
              data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ""), _data$offsets$arrow);
              return data;
            }
            function getOppositeVariation(variation) {
              if (variation === "end") {
                return "start";
              } else if (variation === "start") {
                return "end";
              }
              return variation;
            }
            var placements = ["auto-start", "auto", "auto-end", "top-start", "top", "top-end", "right-start", "right", "right-end", "bottom-end", "bottom", "bottom-start", "left-end", "left", "left-start"];
            var validPlacements = placements.slice(3);
            function clockwise(placement) {
              var counter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              var index = validPlacements.indexOf(placement);
              var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
              return counter ? arr.reverse() : arr;
            }
            var BEHAVIORS = {
              FLIP: "flip",
              CLOCKWISE: "clockwise",
              COUNTERCLOCKWISE: "counterclockwise"
            };
            function flip(data, options) {
              if (isModifierEnabled(data.instance.modifiers, "inner")) {
                return data;
              }
              if (data.flipped && data.placement === data.originalPlacement) {
                return data;
              }
              var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);
              var placement = data.placement.split("-")[0];
              var placementOpposite = getOppositePlacement(placement);
              var variation = data.placement.split("-")[1] || "";
              var flipOrder = [];
              switch (options.behavior) {
                case BEHAVIORS.FLIP:
                  flipOrder = [placement, placementOpposite];
                  break;
                case BEHAVIORS.CLOCKWISE:
                  flipOrder = clockwise(placement);
                  break;
                case BEHAVIORS.COUNTERCLOCKWISE:
                  flipOrder = clockwise(placement, true);
                  break;
                default:
                  flipOrder = options.behavior;
              }
              flipOrder.forEach(function(step, index) {
                if (placement !== step || flipOrder.length === index + 1) {
                  return data;
                }
                placement = data.placement.split("-")[0];
                placementOpposite = getOppositePlacement(placement);
                var popperOffsets = data.offsets.popper;
                var refOffsets = data.offsets.reference;
                var floor = Math.floor;
                var overlapsRef = placement === "left" && floor(popperOffsets.right) > floor(refOffsets.left) || placement === "right" && floor(popperOffsets.left) < floor(refOffsets.right) || placement === "top" && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === "bottom" && floor(popperOffsets.top) < floor(refOffsets.bottom);
                var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
                var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
                var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
                var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);
                var overflowsBoundaries = placement === "left" && overflowsLeft || placement === "right" && overflowsRight || placement === "top" && overflowsTop || placement === "bottom" && overflowsBottom;
                var isVertical = ["top", "bottom"].indexOf(placement) !== -1;
                var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === "start" && overflowsLeft || isVertical && variation === "end" && overflowsRight || !isVertical && variation === "start" && overflowsTop || !isVertical && variation === "end" && overflowsBottom);
                var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === "start" && overflowsRight || isVertical && variation === "end" && overflowsLeft || !isVertical && variation === "start" && overflowsBottom || !isVertical && variation === "end" && overflowsTop);
                var flippedVariation = flippedVariationByRef || flippedVariationByContent;
                if (overlapsRef || overflowsBoundaries || flippedVariation) {
                  data.flipped = true;
                  if (overlapsRef || overflowsBoundaries) {
                    placement = flipOrder[index + 1];
                  }
                  if (flippedVariation) {
                    variation = getOppositeVariation(variation);
                  }
                  data.placement = placement + (variation ? "-" + variation : "");
                  data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));
                  data = runModifiers(data.instance.modifiers, data, "flip");
                }
              });
              return data;
            }
            function keepTogether(data) {
              var _data$offsets = data.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
              var placement = data.placement.split("-")[0];
              var floor = Math.floor;
              var isVertical = ["top", "bottom"].indexOf(placement) !== -1;
              var side = isVertical ? "right" : "bottom";
              var opSide = isVertical ? "left" : "top";
              var measurement = isVertical ? "width" : "height";
              if (popper[side] < floor(reference[opSide])) {
                data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
              }
              if (popper[opSide] > floor(reference[side])) {
                data.offsets.popper[opSide] = floor(reference[side]);
              }
              return data;
            }
            function toValue(str, measurement, popperOffsets, referenceOffsets) {
              var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
              var value = +split[1];
              var unit = split[2];
              if (!value) {
                return str;
              }
              if (unit.indexOf("%") === 0) {
                var element = void 0;
                switch (unit) {
                  case "%p":
                    element = popperOffsets;
                    break;
                  case "%":
                  case "%r":
                  default:
                    element = referenceOffsets;
                }
                var rect = getClientRect(element);
                return rect[measurement] / 100 * value;
              } else if (unit === "vh" || unit === "vw") {
                var size = void 0;
                if (unit === "vh") {
                  size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
                } else {
                  size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
                }
                return size / 100 * value;
              } else {
                return value;
              }
            }
            function parseOffset(offset2, popperOffsets, referenceOffsets, basePlacement) {
              var offsets = [0, 0];
              var useHeight = ["right", "left"].indexOf(basePlacement) !== -1;
              var fragments = offset2.split(/(\+|\-)/).map(function(frag) {
                return frag.trim();
              });
              var divider = fragments.indexOf(find(fragments, function(frag) {
                return frag.search(/,|\s/) !== -1;
              }));
              if (fragments[divider] && fragments[divider].indexOf(",") === -1) {
                console.warn("Offsets separated by white space(s) are deprecated, use a comma (,) instead.");
              }
              var splitRegex = /\s*,\s*|\s+/;
              var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];
              ops = ops.map(function(op, index) {
                var measurement = (index === 1 ? !useHeight : useHeight) ? "height" : "width";
                var mergeWithPrevious = false;
                return op.reduce(function(a, b) {
                  if (a[a.length - 1] === "" && ["+", "-"].indexOf(b) !== -1) {
                    a[a.length - 1] = b;
                    mergeWithPrevious = true;
                    return a;
                  } else if (mergeWithPrevious) {
                    a[a.length - 1] += b;
                    mergeWithPrevious = false;
                    return a;
                  } else {
                    return a.concat(b);
                  }
                }, []).map(function(str) {
                  return toValue(str, measurement, popperOffsets, referenceOffsets);
                });
              });
              ops.forEach(function(op, index) {
                op.forEach(function(frag, index2) {
                  if (isNumeric(frag)) {
                    offsets[index] += frag * (op[index2 - 1] === "-" ? -1 : 1);
                  }
                });
              });
              return offsets;
            }
            function offset(data, _ref) {
              var offset2 = _ref.offset;
              var placement = data.placement, _data$offsets = data.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
              var basePlacement = placement.split("-")[0];
              var offsets = void 0;
              if (isNumeric(+offset2)) {
                offsets = [+offset2, 0];
              } else {
                offsets = parseOffset(offset2, popper, reference, basePlacement);
              }
              if (basePlacement === "left") {
                popper.top += offsets[0];
                popper.left -= offsets[1];
              } else if (basePlacement === "right") {
                popper.top += offsets[0];
                popper.left += offsets[1];
              } else if (basePlacement === "top") {
                popper.left += offsets[0];
                popper.top -= offsets[1];
              } else if (basePlacement === "bottom") {
                popper.left += offsets[0];
                popper.top += offsets[1];
              }
              data.popper = popper;
              return data;
            }
            function preventOverflow(data, options) {
              var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);
              if (data.instance.reference === boundariesElement) {
                boundariesElement = getOffsetParent(boundariesElement);
              }
              var transformProp = getSupportedPropertyName("transform");
              var popperStyles = data.instance.popper.style;
              var top = popperStyles.top, left = popperStyles.left, transform2 = popperStyles[transformProp];
              popperStyles.top = "";
              popperStyles.left = "";
              popperStyles[transformProp] = "";
              var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);
              popperStyles.top = top;
              popperStyles.left = left;
              popperStyles[transformProp] = transform2;
              options.boundaries = boundaries;
              var order = options.priority;
              var popper = data.offsets.popper;
              var check = {
                primary: function primary(placement) {
                  var value = popper[placement];
                  if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
                    value = Math.max(popper[placement], boundaries[placement]);
                  }
                  return defineProperty({}, placement, value);
                },
                secondary: function secondary(placement) {
                  var mainSide = placement === "right" ? "left" : "top";
                  var value = popper[mainSide];
                  if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
                    value = Math.min(popper[mainSide], boundaries[placement] - (placement === "right" ? popper.width : popper.height));
                  }
                  return defineProperty({}, mainSide, value);
                }
              };
              order.forEach(function(placement) {
                var side = ["left", "top"].indexOf(placement) !== -1 ? "primary" : "secondary";
                popper = _extends({}, popper, check[side](placement));
              });
              data.offsets.popper = popper;
              return data;
            }
            function shift(data) {
              var placement = data.placement;
              var basePlacement = placement.split("-")[0];
              var shiftvariation = placement.split("-")[1];
              if (shiftvariation) {
                var _data$offsets = data.offsets, reference = _data$offsets.reference, popper = _data$offsets.popper;
                var isVertical = ["bottom", "top"].indexOf(basePlacement) !== -1;
                var side = isVertical ? "left" : "top";
                var measurement = isVertical ? "width" : "height";
                var shiftOffsets = {
                  start: defineProperty({}, side, reference[side]),
                  end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
                };
                data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
              }
              return data;
            }
            function hide(data) {
              if (!isModifierRequired(data.instance.modifiers, "hide", "preventOverflow")) {
                return data;
              }
              var refRect = data.offsets.reference;
              var bound = find(data.instance.modifiers, function(modifier) {
                return modifier.name === "preventOverflow";
              }).boundaries;
              if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
                if (data.hide === true) {
                  return data;
                }
                data.hide = true;
                data.attributes["x-out-of-boundaries"] = "";
              } else {
                if (data.hide === false) {
                  return data;
                }
                data.hide = false;
                data.attributes["x-out-of-boundaries"] = false;
              }
              return data;
            }
            function inner(data) {
              var placement = data.placement;
              var basePlacement = placement.split("-")[0];
              var _data$offsets = data.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
              var isHoriz = ["left", "right"].indexOf(basePlacement) !== -1;
              var subtractLength = ["top", "left"].indexOf(basePlacement) === -1;
              popper[isHoriz ? "left" : "top"] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? "width" : "height"] : 0);
              data.placement = getOppositePlacement(placement);
              data.offsets.popper = getClientRect(popper);
              return data;
            }
            var modifiers = {
              /**
               * Modifier used to shift the popper on the start or end of its reference
               * element.<br />
               * It will read the variation of the `placement` property.<br />
               * It can be one either `-end` or `-start`.
               * @memberof modifiers
               * @inner
               */
              shift: {
                /** @prop {number} order=100 - Index used to define the order of execution */
                order: 100,
                /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
                enabled: true,
                /** @prop {ModifierFn} */
                fn: shift
              },
              /**
               * The `offset` modifier can shift your popper on both its axis.
               *
               * It accepts the following units:
               * - `px` or unit-less, interpreted as pixels
               * - `%` or `%r`, percentage relative to the length of the reference element
               * - `%p`, percentage relative to the length of the popper element
               * - `vw`, CSS viewport width unit
               * - `vh`, CSS viewport height unit
               *
               * For length is intended the main axis relative to the placement of the popper.<br />
               * This means that if the placement is `top` or `bottom`, the length will be the
               * `width`. In case of `left` or `right`, it will be the `height`.
               *
               * You can provide a single value (as `Number` or `String`), or a pair of values
               * as `String` divided by a comma or one (or more) white spaces.<br />
               * The latter is a deprecated method because it leads to confusion and will be
               * removed in v2.<br />
               * Additionally, it accepts additions and subtractions between different units.
               * Note that multiplications and divisions aren't supported.
               *
               * Valid examples are:
               * ```
               * 10
               * '10%'
               * '10, 10'
               * '10%, 10'
               * '10 + 10%'
               * '10 - 5vh + 3%'
               * '-10px + 5vh, 5px - 6%'
               * ```
               * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
               * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
               * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
               *
               * @memberof modifiers
               * @inner
               */
              offset: {
                /** @prop {number} order=200 - Index used to define the order of execution */
                order: 200,
                /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
                enabled: true,
                /** @prop {ModifierFn} */
                fn: offset,
                /** @prop {Number|String} offset=0
                 * The offset value as described in the modifier description
                 */
                offset: 0
              },
              /**
               * Modifier used to prevent the popper from being positioned outside the boundary.
               *
               * A scenario exists where the reference itself is not within the boundaries.<br />
               * We can say it has "escaped the boundaries"  or just "escaped".<br />
               * In this case we need to decide whether the popper should either:
               *
               * - detach from the reference and remain "trapped" in the boundaries, or
               * - if it should ignore the boundary and "escape with its reference"
               *
               * When `escapeWithReference` is set to`true` and reference is completely
               * outside its boundaries, the popper will overflow (or completely leave)
               * the boundaries in order to remain attached to the edge of the reference.
               *
               * @memberof modifiers
               * @inner
               */
              preventOverflow: {
                /** @prop {number} order=300 - Index used to define the order of execution */
                order: 300,
                /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
                enabled: true,
                /** @prop {ModifierFn} */
                fn: preventOverflow,
                /**
                 * @prop {Array} [priority=['left','right','top','bottom']]
                 * Popper will try to prevent overflow following these priorities by default,
                 * then, it could overflow on the left and on top of the `boundariesElement`
                 */
                priority: ["left", "right", "top", "bottom"],
                /**
                 * @prop {number} padding=5
                 * Amount of pixel used to define a minimum distance between the boundaries
                 * and the popper. This makes sure the popper always has a little padding
                 * between the edges of its container
                 */
                padding: 5,
                /**
                 * @prop {String|HTMLElement} boundariesElement='scrollParent'
                 * Boundaries used by the modifier. Can be `scrollParent`, `window`,
                 * `viewport` or any DOM element.
                 */
                boundariesElement: "scrollParent"
              },
              /**
               * Modifier used to make sure the reference and its popper stay near each other
               * without leaving any gap between the two. Especially useful when the arrow is
               * enabled and you want to ensure that it points to its reference element.
               * It cares only about the first axis. You can still have poppers with margin
               * between the popper and its reference element.
               * @memberof modifiers
               * @inner
               */
              keepTogether: {
                /** @prop {number} order=400 - Index used to define the order of execution */
                order: 400,
                /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
                enabled: true,
                /** @prop {ModifierFn} */
                fn: keepTogether
              },
              /**
               * This modifier is used to move the `arrowElement` of the popper to make
               * sure it is positioned between the reference element and its popper element.
               * It will read the outer size of the `arrowElement` node to detect how many
               * pixels of conjunction are needed.
               *
               * It has no effect if no `arrowElement` is provided.
               * @memberof modifiers
               * @inner
               */
              arrow: {
                /** @prop {number} order=500 - Index used to define the order of execution */
                order: 500,
                /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
                enabled: true,
                /** @prop {ModifierFn} */
                fn: arrow,
                /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
                element: "[x-arrow]"
              },
              /**
               * Modifier used to flip the popper's placement when it starts to overlap its
               * reference element.
               *
               * Requires the `preventOverflow` modifier before it in order to work.
               *
               * **NOTE:** this modifier will interrupt the current update cycle and will
               * restart it if it detects the need to flip the placement.
               * @memberof modifiers
               * @inner
               */
              flip: {
                /** @prop {number} order=600 - Index used to define the order of execution */
                order: 600,
                /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
                enabled: true,
                /** @prop {ModifierFn} */
                fn: flip,
                /**
                 * @prop {String|Array} behavior='flip'
                 * The behavior used to change the popper's placement. It can be one of
                 * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
                 * placements (with optional variations)
                 */
                behavior: "flip",
                /**
                 * @prop {number} padding=5
                 * The popper will flip if it hits the edges of the `boundariesElement`
                 */
                padding: 5,
                /**
                 * @prop {String|HTMLElement} boundariesElement='viewport'
                 * The element which will define the boundaries of the popper position.
                 * The popper will never be placed outside of the defined boundaries
                 * (except if `keepTogether` is enabled)
                 */
                boundariesElement: "viewport",
                /**
                 * @prop {Boolean} flipVariations=false
                 * The popper will switch placement variation between `-start` and `-end` when
                 * the reference element overlaps its boundaries.
                 *
                 * The original placement should have a set variation.
                 */
                flipVariations: false,
                /**
                 * @prop {Boolean} flipVariationsByContent=false
                 * The popper will switch placement variation between `-start` and `-end` when
                 * the popper element overlaps its reference boundaries.
                 *
                 * The original placement should have a set variation.
                 */
                flipVariationsByContent: false
              },
              /**
               * Modifier used to make the popper flow toward the inner of the reference element.
               * By default, when this modifier is disabled, the popper will be placed outside
               * the reference element.
               * @memberof modifiers
               * @inner
               */
              inner: {
                /** @prop {number} order=700 - Index used to define the order of execution */
                order: 700,
                /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
                enabled: false,
                /** @prop {ModifierFn} */
                fn: inner
              },
              /**
               * Modifier used to hide the popper when its reference element is outside of the
               * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
               * be used to hide with a CSS selector the popper when its reference is
               * out of boundaries.
               *
               * Requires the `preventOverflow` modifier before it in order to work.
               * @memberof modifiers
               * @inner
               */
              hide: {
                /** @prop {number} order=800 - Index used to define the order of execution */
                order: 800,
                /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
                enabled: true,
                /** @prop {ModifierFn} */
                fn: hide
              },
              /**
               * Computes the style that will be applied to the popper element to gets
               * properly positioned.
               *
               * Note that this modifier will not touch the DOM, it just prepares the styles
               * so that `applyStyle` modifier can apply it. This separation is useful
               * in case you need to replace `applyStyle` with a custom implementation.
               *
               * This modifier has `850` as `order` value to maintain backward compatibility
               * with previous versions of Popper.js. Expect the modifiers ordering method
               * to change in future major versions of the library.
               *
               * @memberof modifiers
               * @inner
               */
              computeStyle: {
                /** @prop {number} order=850 - Index used to define the order of execution */
                order: 850,
                /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
                enabled: true,
                /** @prop {ModifierFn} */
                fn: computeStyle,
                /**
                 * @prop {Boolean} gpuAcceleration=true
                 * If true, it uses the CSS 3D transformation to position the popper.
                 * Otherwise, it will use the `top` and `left` properties
                 */
                gpuAcceleration: true,
                /**
                 * @prop {string} [x='bottom']
                 * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
                 * Change this if your popper should grow in a direction different from `bottom`
                 */
                x: "bottom",
                /**
                 * @prop {string} [x='left']
                 * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
                 * Change this if your popper should grow in a direction different from `right`
                 */
                y: "right"
              },
              /**
               * Applies the computed styles to the popper element.
               *
               * All the DOM manipulations are limited to this modifier. This is useful in case
               * you want to integrate Popper.js inside a framework or view library and you
               * want to delegate all the DOM manipulations to it.
               *
               * Note that if you disable this modifier, you must make sure the popper element
               * has its position set to `absolute` before Popper.js can do its work!
               *
               * Just disable this modifier and define your own to achieve the desired effect.
               *
               * @memberof modifiers
               * @inner
               */
              applyStyle: {
                /** @prop {number} order=900 - Index used to define the order of execution */
                order: 900,
                /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
                enabled: true,
                /** @prop {ModifierFn} */
                fn: applyStyle,
                /** @prop {Function} */
                onLoad: applyStyleOnLoad,
                /**
                 * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
                 * @prop {Boolean} gpuAcceleration=true
                 * If true, it uses the CSS 3D transformation to position the popper.
                 * Otherwise, it will use the `top` and `left` properties
                 */
                gpuAcceleration: void 0
              }
            };
            var Defaults = {
              /**
               * Popper's placement.
               * @prop {Popper.placements} placement='bottom'
               */
              placement: "bottom",
              /**
               * Set this to true if you want popper to position it self in 'fixed' mode
               * @prop {Boolean} positionFixed=false
               */
              positionFixed: false,
              /**
               * Whether events (resize, scroll) are initially enabled.
               * @prop {Boolean} eventsEnabled=true
               */
              eventsEnabled: true,
              /**
               * Set to true if you want to automatically remove the popper when
               * you call the `destroy` method.
               * @prop {Boolean} removeOnDestroy=false
               */
              removeOnDestroy: false,
              /**
               * Callback called when the popper is created.<br />
               * By default, it is set to no-op.<br />
               * Access Popper.js instance with `data.instance`.
               * @prop {onCreate}
               */
              onCreate: function onCreate() {
              },
              /**
               * Callback called when the popper is updated. This callback is not called
               * on the initialization/creation of the popper, but only on subsequent
               * updates.<br />
               * By default, it is set to no-op.<br />
               * Access Popper.js instance with `data.instance`.
               * @prop {onUpdate}
               */
              onUpdate: function onUpdate() {
              },
              /**
               * List of modifiers used to modify the offsets before they are applied to the popper.
               * They provide most of the functionalities of Popper.js.
               * @prop {modifiers}
               */
              modifiers
            };
            var Popper = function() {
              function Popper2(reference, popper) {
                var _this = this;
                var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                classCallCheck(this, Popper2);
                this.scheduleUpdate = function() {
                  return requestAnimationFrame(_this.update);
                };
                this.update = debounce(this.update.bind(this));
                this.options = _extends({}, Popper2.Defaults, options);
                this.state = {
                  isDestroyed: false,
                  isCreated: false,
                  scrollParents: []
                };
                this.reference = reference && reference.jquery ? reference[0] : reference;
                this.popper = popper && popper.jquery ? popper[0] : popper;
                this.options.modifiers = {};
                Object.keys(_extends({}, Popper2.Defaults.modifiers, options.modifiers)).forEach(function(name) {
                  _this.options.modifiers[name] = _extends({}, Popper2.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
                });
                this.modifiers = Object.keys(this.options.modifiers).map(function(name) {
                  return _extends({
                    name
                  }, _this.options.modifiers[name]);
                }).sort(function(a, b) {
                  return a.order - b.order;
                });
                this.modifiers.forEach(function(modifierOptions) {
                  if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
                    modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
                  }
                });
                this.update();
                var eventsEnabled = this.options.eventsEnabled;
                if (eventsEnabled) {
                  this.enableEventListeners();
                }
                this.state.eventsEnabled = eventsEnabled;
              }
              createClass(Popper2, [{
                key: "update",
                value: function update$$1() {
                  return update.call(this);
                }
              }, {
                key: "destroy",
                value: function destroy$$1() {
                  return destroy.call(this);
                }
              }, {
                key: "enableEventListeners",
                value: function enableEventListeners$$1() {
                  return enableEventListeners.call(this);
                }
              }, {
                key: "disableEventListeners",
                value: function disableEventListeners$$1() {
                  return disableEventListeners.call(this);
                }
                /**
                 * Schedules an update. It will run on the next UI update available.
                 * @method scheduleUpdate
                 * @memberof Popper
                 */
                /**
                 * Collection of utilities useful when writing custom modifiers.
                 * Starting from version 1.7, this method is available only if you
                 * include `popper-utils.js` before `popper.js`.
                 *
                 * **DEPRECATION**: This way to access PopperUtils is deprecated
                 * and will be removed in v2! Use the PopperUtils module directly instead.
                 * Due to the high instability of the methods contained in Utils, we can't
                 * guarantee them to follow semver. Use them at your own risk!
                 * @static
                 * @private
                 * @type {Object}
                 * @deprecated since version 1.8
                 * @member Utils
                 * @memberof Popper
                 */
              }]);
              return Popper2;
            }();
            Popper.Utils = (typeof window !== "undefined" ? window : global).PopperUtils;
            Popper.placements = placements;
            Popper.Defaults = Defaults;
            __webpack_exports__["a"] = Popper;
          }).call(this, __webpack_require__("c8ba"));
        }
      ),
      /***/
      "fb15": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.r(__webpack_exports__);
          __webpack_require__.d(__webpack_exports__, "Scrollbars", function() {
            return (
              /* reexport */
              scrollbar_Scrollbars
            );
          });
          if (typeof window !== "undefined") {
            var currentScript = window.document.currentScript;
            if (true) {
              var getCurrentScript = __webpack_require__("8875");
              currentScript = getCurrentScript();
              if (!("currentScript" in document)) {
                Object.defineProperty(document, "currentScript", { get: getCurrentScript });
              }
            }
            var src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/);
            if (src) {
              __webpack_require__.p = src[1];
            }
          }
          var setPublicPath = null;
          var ResizeObserver_es = __webpack_require__("6dd8");
          class scrollbar_Scrollbars {
            constructor(el, options) {
              this.options = options;
              this.onScroll = this.onScroll.bind(this);
              this.onDocumentMousemove = this.onDocumentMousemove.bind(this);
              this.onDocumentMouseup = this.onDocumentMouseup.bind(this);
              this.onThumbMousedownX = this.onThumbMousedown.bind(this, "x");
              this.onThumbMousedownY = this.onThumbMousedown.bind(this, "y");
              this.onResize = this.onResize.bind(this);
              this.el = el;
              this.railsParent = options.railsParent || this.el;
              this.refreshStyling();
              if (options.scrollX)
                this.createRail("x");
              if (options.scrollY)
                this.createRail("y");
              if (!options.manualCompute) {
                this.computeDimensions();
                this.computeThumbPositions();
                this.update();
              }
              this.el.addEventListener("scroll", this.onScroll);
              if (!options.manualUpdate) {
                this.resizeObserver = new ResizeObserver_es[
                  "a"
                  /* default */
                ](this.onResize);
                this.resizeObserver.observe(this.el);
                for (const el2 of this.el.children) {
                  this.resizeObserver.observe(el2);
                }
                this.mutationObserver = new MutationObserver((records) => {
                  for (const record of records) {
                    for (const addedNode of record.addedNodes) {
                      if (addedNode.nodeType !== Node.ELEMENT_NODE)
                        continue;
                      this.resizeObserver.observe(addedNode);
                    }
                    for (const removedNode of record.removedNodes) {
                      if (removedNode.nodeType !== Node.ELEMENT_NODE)
                        continue;
                      this.resizeObserver.unobserve(removedNode);
                    }
                  }
                  this.onResize();
                });
                this.mutationObserver.observe(this.el, {
                  childList: true
                });
              }
            }
            createRail(dimension) {
              const railWrapperEl = document.createElement("div");
              railWrapperEl.classList.add(`bunt-scrollbar-rail-wrapper-${dimension}`);
              const railEl = document.createElement("div");
              railEl.classList.add(`bunt-scrollbar-rail-${dimension}`);
              const thumbEl = document.createElement("div");
              thumbEl.classList.add("bunt-scrollbar-thumb");
              railWrapperEl.appendChild(railEl);
              railEl.appendChild(thumbEl);
              this.railsParent.appendChild(railWrapperEl);
              thumbEl.addEventListener("mousedown", this[`onThumbMousedown${dimension.toUpperCase()}`]);
              this[dimension] = {
                railEl,
                thumbEl
              };
            }
            destroy() {
              var _this$resizeObserver, _this$mutationObserve, _this$x, _this$y;
              (_this$resizeObserver = this.resizeObserver) === null || _this$resizeObserver === void 0 ? void 0 : _this$resizeObserver.disconnect();
              (_this$mutationObserve = this.mutationObserver) === null || _this$mutationObserve === void 0 ? void 0 : _this$mutationObserve.disconnect();
              document.removeEventListener("mousemove", this.onDocumentMousemove);
              document.removeEventListener("mouseup", this.onDocumentMouseup, {
                capture: true
              });
              this.el.removeEventListener("scroll", this.onScroll);
              (_this$x = this.x) === null || _this$x === void 0 ? void 0 : _this$x.thumbEl.removeEventListener("mousedown", this.onThumbMousedownX);
              (_this$y = this.y) === null || _this$y === void 0 ? void 0 : _this$y.thumbEl.removeEventListener("mousedown", this.onThumbMousedownY);
            }
            refreshStyling() {
              this.el.classList.add("bunt-scrollbar");
            }
            update() {
              this.updateThumb("x");
              this.updateThumb("y");
            }
            // EVENTS
            onScroll(event) {
              if (this.options.onScroll) {
                this.options.onScroll(event);
              }
              this.computeThumbPositions();
              this.update();
            }
            onThumbMousedown(dimension, event) {
              event.stopPropagation();
              if (this.options._preventMousedown) {
                event.preventDefault();
              }
              this.dragging = dimension;
              this.draggingOffset = event[`offset${dimension.toUpperCase()}`];
              this.el.style.userSelect = "none";
              document.body.style["-moz-user-select"] = "none";
              this[dimension].railEl.classList.add("active");
              document.addEventListener("mousemove", this.onDocumentMousemove);
              document.addEventListener("mouseup", this.onDocumentMouseup, {
                capture: true
              });
            }
            onDocumentMousemove(event) {
              if (this.dragging === "x") {
                const maxX = this.el.clientWidth - this.x.thumbLength;
                const newPosition = event.clientX - this.el.getBoundingClientRect().left - this.draggingOffset;
                this.x.thumbPosition = Math.min(Math.max(0, newPosition), maxX);
                this.el.scrollLeft = this.x.thumbPosition / maxX * (this.el.scrollWidth - this.el.clientWidth);
              }
              if (this.dragging === "y") {
                const maxY = this.el.clientHeight - this.y.thumbLength;
                const newPosition = event.clientY - this.el.getBoundingClientRect().top - this.draggingOffset;
                this.y.thumbPosition = Math.min(Math.max(0, newPosition), maxY);
                this.el.scrollTop = this.y.thumbPosition / maxY * (this.el.scrollHeight - this.el.clientHeight);
              }
              this.updateThumb(this.dragging);
            }
            onDocumentMouseup(event) {
              this[this.dragging].railEl.classList.remove("active");
              this.dragging = null;
              this.el.style.userSelect = "";
              document.body.style["-moz-user-select"] = "";
              document.removeEventListener("mousemove", this.onDocumentMousemove);
              document.removeEventListener("mouseup", this.onDocumentMouseup, {
                capture: true
              });
            }
            onResize(entries) {
              this.computeDimensions();
              this.computeThumbPositions();
              this.update();
            }
            // COMPUTATIONS
            computeDimensions() {
              if (this.x) {
                this.x.railLength = this.el.clientWidth;
                this.x.visibleRatio = this.el.clientWidth / this.el.scrollWidth;
                this.x.thumbLength = this.el.clientWidth * this.x.visibleRatio;
              }
              if (this.y) {
                this.y.railLength = this.el.clientHeight;
                this.y.visibleRatio = this.el.clientHeight / this.el.scrollHeight;
                this.y.thumbLength = this.el.clientHeight * this.y.visibleRatio;
              }
            }
            computeThumbPositions() {
              if (this.x) {
                this.x.thumbPosition = this.el.scrollLeft / (this.el.scrollWidth - this.el.clientWidth) * (this.el.clientWidth - this.x.thumbLength);
              }
              if (this.y) {
                this.y.thumbPosition = this.el.scrollTop / (this.el.scrollHeight - this.el.clientHeight) * (this.el.clientHeight - this.y.thumbLength);
              }
            }
            updateThumb(dimension) {
              const state = this[dimension];
              if (!state)
                return;
              if (state.visibleRatio >= 1) {
                state.thumbEl.style.display = "none";
              } else {
                state.thumbEl.style.display = null;
                if (dimension === "x") {
                  state.railEl.style.width = state.railLength + "px";
                  state.thumbEl.style.width = state.thumbLength + "px";
                  state.thumbEl.style.left = state.thumbPosition + "px";
                } else if (dimension === "y") {
                  state.railEl.style.height = state.railLength + "px";
                  state.thumbEl.style.height = state.thumbLength + "px";
                  state.thumbEl.style.top = state.thumbPosition + "px";
                }
              }
            }
          }
          var scrollbar = function(Vue) {
            Vue.directive("scrollbar", {
              mounted(el, binding, vnode) {
                var _binding$value;
                el.__buntpapier__scrollbar = new scrollbar_Scrollbars(el, {
                  scrollX: binding.modifiers.x,
                  scrollY: binding.modifiers.y,
                  _preventMousedown: (_binding$value = binding.value) === null || _binding$value === void 0 ? void 0 : _binding$value._preventMousedown
                });
                el.__buntpapier__scrollbar.refreshStyling();
                el.__buntpapier__scrollbar.update();
              },
              updated(el, binding, vnode, oldVnode) {
                if (!el.__buntpapier__scrollbar) {
                  el.__buntpapier__scrollbar = new scrollbar_Scrollbars(el, {
                    scrollX: binding.modifiers.x,
                    scrollY: binding.modifiers.y
                  });
                } else {
                  el.__buntpapier__scrollbar.refreshStyling();
                  el.__buntpapier__scrollbar.update();
                }
              },
              beforeUnmount(el, binding, vnode, oldVnode) {
                if (!el.__buntpapier__scrollbar)
                  return;
                el.__buntpapier__scrollbar.destroy();
              }
            });
          };
          var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__("8bbf");
          var popper = __webpack_require__("f0bd");
          const ANIMATION_OFFSET = 32;
          var tooltip = function(Vue) {
            class Tooltip {
              constructor(el, options) {
                this.el = el;
                this.options = options;
                this.show = this.show.bind(this);
                this.hide = this.hide.bind(this);
                this.options.placement = options.placement || "auto";
                this.el.addEventListener("mouseenter", this.show);
                this.el.addEventListener("mouseleave", this.hide);
              }
              createTooltip() {
                if (this.tooltipEl)
                  return;
                this.tooltipEl = document.createElement("div");
                this.tooltipEl.classList.add("bunt-tooltip");
                this.tooltipEl.style.position = this.options.fixed ? "fixed" : "absolute";
                this.tooltipEl.textContent = this.text;
                this.el.appendChild(this.tooltipEl);
                this.popper = new popper[
                  "a"
                  /* default */
                ](this.el, this.tooltipEl, {
                  removeOnDestroy: true,
                  placement: this.options.placement,
                  positionFixed: this.options.fixed,
                  modifiers: {
                    offset: {
                      offset: "0, 8"
                    },
                    applyStyle: {
                      enabled: false
                    },
                    preventOverflow: {
                      boundariesElement: this.options.boundariesElement || "scrollParent"
                    },
                    applyTooltipStyle: {
                      enabled: true,
                      fn: (data) => {
                        this.positions = data.popper;
                        this.tooltipEl.style.transform = `translate3d(${Math.round(this.positions.left)}px, ${Math.round(this.positions.top)}px, 0)`;
                      },
                      order: 900
                    }
                  }
                });
              }
              update(text, forceDisplay) {
                this.text = text;
                const oldForceDisplay = this.forceDisplay;
                this.forceDisplay = forceDisplay;
                Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(() => {
                  if (forceDisplay) {
                    if (!oldForceDisplay)
                      this.show();
                  } else {
                    if (oldForceDisplay)
                      this.hide();
                  }
                  if (this.tooltipEl)
                    this.tooltipEl.textContent = this.text;
                  if (this.popper)
                    this.popper.update();
                });
              }
              destroyTooltip() {
                if (!this.popper)
                  return;
                this.popper.destroy();
                this.popper = null;
                this.tooltipEl = null;
              }
              destroy() {
                this.destroyTooltip();
                this.el.removeEventListener("mouseenter", this.show);
                this.el.removeEventListener("mouseleave", this.hide);
              }
              show() {
                if (this.displaying || !this.text)
                  return;
                this.createTooltip();
                this.displaying = true;
                Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(() => {
                  if (this.animation) {
                    this.animation.reverse();
                  } else {
                    let animationOrigin;
                    if (this.options.placement.startsWith("top")) {
                      animationOrigin = {
                        top: Math.round(this.positions.top) + ANIMATION_OFFSET,
                        left: Math.round(this.positions.left)
                      };
                    } else if (this.options.placement.startsWith("left")) {
                      animationOrigin = {
                        top: Math.round(this.positions.top),
                        left: Math.round(this.positions.left) + ANIMATION_OFFSET
                      };
                    } else if (this.options.placement.startsWith("right")) {
                      animationOrigin = {
                        top: Math.round(this.positions.top),
                        left: Math.round(this.positions.left) - ANIMATION_OFFSET
                      };
                    } else {
                      animationOrigin = {
                        top: Math.round(this.positions.top) - ANIMATION_OFFSET,
                        left: Math.round(this.positions.left)
                      };
                    }
                    this.animation = this.tooltipEl.animate([{
                      transform: `translate3d(${animationOrigin.left}px, ${animationOrigin.top}px, 0)`,
                      opacity: 0
                    }, {
                      transform: `translate3d(${Math.round(this.positions.left)}px, ${Math.round(this.positions.top)}px, 0)`,
                      opacity: 1
                    }], {
                      duration: 200,
                      easing: "ease-in-out"
                    });
                    this.animation.onfinish = () => {
                      if (this.animation && this.animation.playbackRate < 0) {
                        this.destroyTooltip();
                        this.animation = null;
                      }
                    };
                  }
                });
              }
              hide() {
                if (!this.displaying || this.forceDisplay)
                  return;
                this.displaying = false;
                if (this.animation) {
                  this.animation.reverse();
                }
                if (!this.text) {
                  this.destroyTooltip();
                }
              }
            }
            Vue.directive("tooltip", {
              mounted(el, binding, vnode) {
                let text;
                if (typeof binding.value === "string") {
                  text = binding.value;
                } else {
                  text = binding.value.text;
                }
                el.__buntpapier__tooltip = new Tooltip(el, {
                  placement: binding.value.placement || Object.keys(binding.modifiers).find((mod) => ["auto", "top", "right", "bottom", "left"].find((pos) => mod.startsWith(pos))),
                  fixed: binding.value.fixed || binding.modifiers.fixed,
                  boundariesElement: binding.value.boundariesElement
                });
                el.__buntpapier__tooltip.update(text, binding.value.show);
              },
              updated(el, binding, vnode, oldVnode) {
                if (!el.__buntpapier__tooltip || binding.value === binding.oldValue)
                  return;
                let text;
                if (typeof binding.value === "string") {
                  text = binding.value;
                } else {
                  text = binding.value.text;
                }
                el.__buntpapier__tooltip.update(text, binding.value.show);
              },
              unmounted(el, binding, vnode, oldVnode) {
                if (!el.__buntpapier__tooltip)
                  return;
                el.__buntpapier__tooltip.destroy();
              }
            });
          };
          var directives = function(Vue) {
            Vue.directive("resizeObserver", {
              beforeMount(el, binding) {
                const observer = new ResizeObserver_es[
                  "a"
                  /* default */
                ]((entries) => {
                  if (!el.__buntpapier__resize_observer)
                    return;
                  for (const handler of el.__buntpapier__resize_observer.handlers) {
                    handler(entries);
                  }
                });
                if (!el.__buntpapier__resize_observer) {
                  el.__buntpapier__resize_observer = {
                    observer,
                    handlers: [binding.value]
                  };
                } else {
                  el.__buntpapier__resize_observer.handlers.push(binding.value);
                }
                observer.observe(el);
              },
              beforeUnmount(el, binding, vnode, oldVnode) {
                if (!el.__buntpapier__resize_observer)
                  return;
                el.__buntpapier__resize_observer.observer.disconnect();
                el.__buntpapier__resize_observer = null;
              }
            });
            scrollbar(Vue);
            tooltip(Vue);
          };
          const _hoisted_1 = ["type", "aria-disabled"];
          const _hoisted_2 = {
            class: "bunt-button-text"
          };
          const _hoisted_3 = ["textContent"];
          const _hoisted_4 = {
            key: 0,
            class: "bunt-icon mdi mdi-replay error"
          };
          const _hoisted_5 = {
            key: 1,
            class: "bunt-icon mdi mdi-check success"
          };
          function render(_ctx, _cache, $props, $setup, $data, $options) {
            const _component_progress_circular = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["resolveComponent"])("progress-circular");
            const _component_ripple_ink = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["resolveComponent"])("ripple-ink");
            const _directive_tooltip = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["resolveDirective"])("tooltip");
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withDirectives"])((Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("button", {
              class: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeClass"])(["bunt-button", {
                disabled: $props.disabled || $props.loading || $data.showSuccess,
                error: $props.errorMessage || $props.error,
                success: $data.showSuccess
              }]),
              type: $props.type,
              ref: "button",
              onClick: _cache[0] || (_cache[0] = (...args) => $options.onClick && $options.onClick(...args)),
              "aria-disabled": $props.disabled
            }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("div", {
              class: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeClass"])(["bunt-button-content", {
                invisible: $props.loading || $props.errorMessage || $props.error || $data.showSuccess
              }])
            }, [$props.icon ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("i", {
              key: 0,
              class: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeClass"])(["bunt-icon mdi", [$options.iconClass]])
            }, null, 2)) : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("div", _hoisted_2, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default", {}, () => [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("span", {
              textContent: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toDisplayString"])($props.text)
            }, null, 8, _hoisted_3)])])], 2), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withDirectives"])(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(_component_progress_circular, {
              size: "small"
            }, null, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_["vShow"], $props.loading]]), $props.errorMessage || $props.error ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("i", _hoisted_4)) : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true), $data.showSuccess ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("i", _hoisted_5)) : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true), !$props.disabled ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createBlock"])(_component_ripple_ink, {
              key: 2
            })) : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true)], 10, _hoisted_1)), [[_directive_tooltip, $props.tooltipOptions || {
              text: $options._tooltip,
              show: !!this.errorMessage,
              placement: $props.tooltipPlacement,
              fixed: $props.tooltipFixed
            }]]);
          }
          function ripple_inkvue_type_template_id_baf9dbee_lang_pug_render(_ctx, _cache, $props, $setup, $data, $options) {
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("div", {
              class: "bunt-ripple-ink",
              onMousedown: _cache[0] || (_cache[0] = ($event) => $options.mousedown($event)),
              onTouchstartPassive: _cache[1] || (_cache[1] = ($event) => $options.touchstart($event))
            }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(external_commonjs_vue_commonjs2_vue_root_Vue_["Transition"], {
              name: "ripple-ink"
            }, {
              default: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withCtx"])(() => [$data.show ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("div", {
                key: 0,
                class: "ripple",
                style: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeStyle"])($data.style)
              }, null, 4)) : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true)]),
              _: 1
            })], 32);
          }
          var ripple_inkvue_type_script_lang_js = {
            name: `bunt-ripple-ink`,
            data() {
              return {
                show: false,
                style: null
              };
            },
            methods: {
              mousedown(e) {
                if (e.button === 0) {
                  this.ripple(e.type, e);
                }
              },
              touchstart(e) {
                if (e.changedTouches) {
                  for (let i = 0; i < e.changedTouches.length; ++i) {
                    this.ripple(e.type, e.changedTouches[i]);
                  }
                }
              },
              ripple(eventType, e) {
                const holder = this.$el;
                const prev = holder.getAttribute("data-ui-event");
                if (prev && prev !== eventType) {
                  return;
                }
                holder.setAttribute("data-ui-event", eventType);
                let rect = holder.getBoundingClientRect();
                let x = e.offsetX;
                let y;
                if (x !== void 0) {
                  y = e.offsetY;
                } else {
                  x = e.clientX - rect.left;
                  y = e.clientY - rect.top;
                }
                let max = rect.width === rect.height ? rect.width * 1.412 : Math.sqrt(rect.width * rect.width + rect.height * rect.height);
                let dim = max * 2 + "px";
                this.style = {
                  width: dim,
                  height: dim,
                  marginLeft: -max + x + "px",
                  marginTop: -max + y + "px"
                };
                this.show = true;
                const releaseEvents = ["mouseleave", "mouseup", "touchend"];
                const release = () => {
                  releaseEvents.forEach((eventName) => {
                    holder.removeEventListener(eventName, release);
                  });
                  setTimeout(() => {
                    this.show = false;
                    this.style = null;
                    holder.removeAttribute("data-ui-event");
                  }, 200);
                };
                releaseEvents.forEach((eventName) => {
                  holder.addEventListener(eventName, release);
                });
              }
            }
          };
          ripple_inkvue_type_script_lang_js.render = ripple_inkvue_type_template_id_baf9dbee_lang_pug_render;
          var ripple_ink = ripple_inkvue_type_script_lang_js;
          var mixins_ripple_ink = {
            components: {
              RippleInk: ripple_ink
            }
          };
          const progress_circularvue_type_template_id_08572eb2_lang_pug_hoisted_1 = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("svg", {
            viewBox: "25 25 50 50"
          }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("circle", {
            cx: "50",
            cy: "50",
            r: "20"
          })], -1);
          const progress_circularvue_type_template_id_08572eb2_lang_pug_hoisted_2 = [progress_circularvue_type_template_id_08572eb2_lang_pug_hoisted_1];
          function progress_circularvue_type_template_id_08572eb2_lang_pug_render(_ctx, _cache, $props, $setup, $data, $options) {
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("div", {
              class: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeClass"])(["bunt-progress-circular active", [$props.size, {
                "progress-center": $props.center,
                "progress-page": $props.page
              }]])
            }, progress_circularvue_type_template_id_08572eb2_lang_pug_hoisted_2, 2);
          }
          var progress_circularvue_type_script_lang_js = {
            props: {
              center: {
                type: Boolean,
                default: false
              },
              page: {
                type: Boolean,
                default: false
              },
              size: {
                type: String,
                default: "normal"
              }
            },
            data() {
              return {};
            },
            created() {
            },
            beforeUnmount() {
            },
            methods: {}
          };
          progress_circularvue_type_script_lang_js.render = progress_circularvue_type_template_id_08572eb2_lang_pug_render;
          var progress_circular = progress_circularvue_type_script_lang_js;
          const alias = {
            add: "plus",
            done: "check",
            remove: "minus",
            search: "magnify",
            "help_outline": "help-circle-outline"
          };
          var icon = {
            getClass(name) {
              if (!name)
                return "";
              return "mdi-" + (alias[name] || name).replace("_", "-");
            }
          };
          var buttonvue_type_script_lang_js = {
            name: `bunt-button`,
            components: {
              ProgressCircular: progress_circular
            },
            mixins: [mixins_ripple_ink],
            props: {
              text: String,
              icon: String,
              iconRight: {
                type: Boolean,
                default: false
              },
              loading: {
                type: Boolean,
                default: false
              },
              disabled: {
                type: Boolean,
                default: false
              },
              type: {
                type: String,
                default: "button"
              },
              error: Boolean,
              errorMessage: String,
              successAfterLoading: {
                type: Boolean,
                default: true
              },
              tooltip: String,
              tooltipPlacement: {
                type: String,
                default: "bottom"
              },
              tooltipFixed: {
                type: Boolean,
                default: false
              },
              tooltipOptions: Object
            },
            emits: ["click"],
            data() {
              return {
                _loading: false,
                showSuccess: false
              };
            },
            computed: {
              _tooltip() {
                return this.errorMessage ? this.errorMessage : this.tooltip;
              },
              iconClass() {
                return icon.getClass(this.icon);
              }
            },
            watch: {
              loading: "loadingChanged",
              errorMessage: "errorChanged",
              error: "errorChanged"
            },
            methods: {
              loadingChanged(value) {
                if (value) {
                  this._loading = value;
                  this.userShowTooltip = false;
                  this.showSuccess = false;
                  if (this.$successTimeout)
                    clearTimeout(this.$successTimeout);
                } else {
                  this._loading = value;
                  if (this.errorMessage || this.error)
                    return;
                  this.showSuccess = true;
                  this.$successTimeout = setTimeout(() => {
                    this.showSuccess = false;
                  }, 3e3);
                }
              },
              errorChanged(value) {
                if (value !== null)
                  this.showSuccess = false;
              },
              onClick(event) {
                if (this.disabled || this.loading || this.showSuccess)
                  return;
                this.$emit("click", event);
              }
            }
          };
          buttonvue_type_script_lang_js.render = render;
          var src_button = buttonvue_type_script_lang_js;
          const checkboxvue_type_template_id_3026ef63_lang_pug_hoisted_1 = ["name", "checked", "disabled", "readonly"];
          const checkboxvue_type_template_id_3026ef63_lang_pug_hoisted_2 = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("div", {
            class: "bunt-checkbox-box"
          }, null, -1);
          const checkboxvue_type_template_id_3026ef63_lang_pug_hoisted_3 = {
            key: 0
          };
          const checkboxvue_type_template_id_3026ef63_lang_pug_hoisted_4 = {
            key: 1
          };
          function checkboxvue_type_template_id_3026ef63_lang_pug_render(_ctx, _cache, $props, $setup, $data, $options) {
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("div", {
              class: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeClass"])(["bunt-checkbox", {
                checked: $props.modelValue
              }])
            }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("input", {
              type: "checkbox",
              name: $props.name,
              checked: $props.modelValue,
              disabled: $props.disabled,
              readonly: $props.readonly,
              onChange: _cache[0] || (_cache[0] = ($event) => $options.onChange($event)),
              onFocus: _cache[1] || (_cache[1] = ($event) => $data.focused = true),
              onBlur: _cache[2] || (_cache[2] = (...args) => $options.onBlur && $options.onBlur(...args))
            }, null, 40, checkboxvue_type_template_id_3026ef63_lang_pug_hoisted_1), checkboxvue_type_template_id_3026ef63_lang_pug_hoisted_2, $props.label ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("label", checkboxvue_type_template_id_3026ef63_lang_pug_hoisted_3, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toDisplayString"])($props.label), 1)) : (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("label", checkboxvue_type_template_id_3026ef63_lang_pug_hoisted_4, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default")]))], 2);
          }
          var checkboxvue_type_script_lang_js = {
            name: `bunt-checkbox`,
            components: {},
            props: {
              modelValue: {
                type: Boolean,
                default: false
              },
              name: {
                type: String,
                required: true
              },
              label: String,
              disabled: {
                type: Boolean,
                default: false
              },
              readonly: {
                type: Boolean,
                default: false
              }
            },
            emits: ["update:modelValue"],
            data() {
              return {
                focused: false
              };
            },
            methods: {
              onChange($event) {
                this.$emit("update:modelValue", $event.target.checked);
                if (this.validation)
                  this.validation.$touch();
              },
              onBlur() {
                this.focused = false;
                if (this.validation)
                  this.validation.$touch();
              }
            }
          };
          checkboxvue_type_script_lang_js.render = checkboxvue_type_template_id_3026ef63_lang_pug_render;
          var src_checkbox = checkboxvue_type_script_lang_js;
          const radiovue_type_template_id_2ccbc609_lang_pug_hoisted_1 = ["name", "value", "checked", "disabled", "readonly"];
          const radiovue_type_template_id_2ccbc609_lang_pug_hoisted_2 = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("div", {
            class: "bunt-radio-circle"
          }, null, -1);
          const radiovue_type_template_id_2ccbc609_lang_pug_hoisted_3 = {
            key: 0
          };
          const radiovue_type_template_id_2ccbc609_lang_pug_hoisted_4 = {
            key: 1
          };
          function radiovue_type_template_id_2ccbc609_lang_pug_render(_ctx, _cache, $props, $setup, $data, $options) {
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("div", {
              class: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeClass"])(["bunt-radio", {
                checked: $options.isChecked
              }])
            }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("input", {
              type: "radio",
              name: $props.name,
              value: $props.modelValue,
              checked: $options.isChecked,
              disabled: $props.disabled,
              readonly: $props.readonly,
              onChange: _cache[0] || (_cache[0] = ($event) => $options.onChange($event)),
              onFocus: _cache[1] || (_cache[1] = ($event) => $data.focused = true),
              onBlur: _cache[2] || (_cache[2] = (...args) => $options.onBlur && $options.onBlur(...args))
            }, null, 40, radiovue_type_template_id_2ccbc609_lang_pug_hoisted_1), radiovue_type_template_id_2ccbc609_lang_pug_hoisted_2, $props.label ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("label", radiovue_type_template_id_2ccbc609_lang_pug_hoisted_3, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toDisplayString"])($props.label), 1)) : (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("label", radiovue_type_template_id_2ccbc609_lang_pug_hoisted_4, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default")]))], 2);
          }
          var radiovue_type_script_lang_js = {
            name: `bunt-radio`,
            props: {
              modelValue: [Boolean, String],
              value: String,
              name: {
                type: String,
                required: true
              },
              label: String,
              disabled: {
                type: Boolean,
                default: false
              },
              readonly: {
                type: Boolean,
                default: false
              }
            },
            emits: ["update:modelValue"],
            data() {
              return {
                focused: false
              };
            },
            computed: {
              isChecked() {
                return this.value === this.modelValue;
              }
            },
            methods: {
              onChange($event) {
                this.$emit("update:modelValue", this.value);
                if (this.validation)
                  this.validation.$touch();
              },
              onBlur() {
                this.focused = false;
                if (this.validation)
                  this.validation.$touch();
              }
            }
          };
          radiovue_type_script_lang_js.render = radiovue_type_template_id_2ccbc609_lang_pug_render;
          var src_radio = radiovue_type_script_lang_js;
          function iconvue_type_template_id_3c0443cc_lang_pug_render(_ctx, _cache, $props, $setup, $data, $options) {
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("i", {
              class: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeClass"])(["bunt-icon mdi", [$options.iconClass]])
            }, null, 2);
          }
          var iconvue_type_script_lang_js = {
            name: `bunt-icon`,
            props: {
              icon: {
                type: String,
                required: true
              }
            },
            computed: {
              iconClass() {
                return icon.getClass(this.icon);
              }
            }
          };
          iconvue_type_script_lang_js.render = iconvue_type_template_id_3c0443cc_lang_pug_render;
          var src_icon = iconvue_type_script_lang_js;
          const icon_buttonvue_type_template_id_28f73aa6_lang_pug_hoisted_1 = ["type", "aria-disabled"];
          function icon_buttonvue_type_template_id_28f73aa6_lang_pug_render(_ctx, _cache, $props, $setup, $data, $options) {
            const _component_ripple_ink = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["resolveComponent"])("ripple-ink");
            const _directive_tooltip = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["resolveDirective"])("tooltip");
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withDirectives"])((Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("button", {
              class: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeClass"])(["bunt-icon-button", {
                disabled: $props.disabled
              }]),
              type: $props.type,
              "aria-disabled": $props.disabled,
              ref: "button",
              onClick: _cache[0] || (_cache[0] = (...args) => $options.onClick && $options.onClick(...args))
            }, [$options.iconClass() ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("i", {
              key: 0,
              class: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeClass"])(["bunt-icon mdi", [$options.iconClass()]])
            }, null, 2)) : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default", {
              key: 1
            }), !$props.disabled ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createBlock"])(_component_ripple_ink, {
              key: 2
            })) : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true)], 10, icon_buttonvue_type_template_id_28f73aa6_lang_pug_hoisted_1)), [[_directive_tooltip, $props.tooltipOptions || {
              text: $props.tooltip,
              placement: $props.tooltipPlacement,
              fixed: $props.tooltipFixed
            }]]);
          }
          var icon_buttonvue_type_script_lang_js = {
            name: `bunt-icon-button`,
            mixins: [mixins_ripple_ink],
            props: {
              disabled: {
                type: Boolean,
                default: false
              },
              type: {
                type: String,
                default: "button"
              },
              tooltip: String,
              tooltipPlacement: {
                type: String,
                default: "bottom"
              },
              tooltipFixed: {
                type: Boolean,
                default: false
              },
              tooltipOptions: Object
            },
            emits: ["click"],
            data() {
              return {
                showTooltip: false
              };
            },
            methods: {
              iconClass() {
                const slotNode = this.$slots.default()[0];
                if ((slotNode === null || slotNode === void 0 ? void 0 : slotNode.type) === external_commonjs_vue_commonjs2_vue_root_Vue_["Text"])
                  return icon.getClass(slotNode.children);
                return;
              },
              onClick(event) {
                if (this.disabled)
                  return;
                this.$emit("click", event);
              }
            }
          };
          icon_buttonvue_type_script_lang_js.render = icon_buttonvue_type_template_id_28f73aa6_lang_pug_render;
          var icon_button = icon_buttonvue_type_script_lang_js;
          const inputvue_type_template_id_d2b370f8_lang_pug_hoisted_1 = {
            class: "label-input-container"
          };
          const inputvue_type_template_id_d2b370f8_lang_pug_hoisted_2 = ["for"];
          const inputvue_type_template_id_d2b370f8_lang_pug_hoisted_3 = ["type", "name", "value", "disabled", "readonly", "placeholder"];
          const inputvue_type_template_id_d2b370f8_lang_pug_hoisted_4 = ["title"];
          const inputvue_type_template_id_d2b370f8_lang_pug_hoisted_5 = {
            class: "outline",
            ref: "outline"
          };
          const _hoisted_6 = ["d"];
          const _hoisted_7 = ["innerHTML"];
          const _hoisted_8 = {
            key: 1,
            class: "hint"
          };
          function inputvue_type_template_id_d2b370f8_lang_pug_render(_ctx, _cache, $props, $setup, $data, $options) {
            const _directive_resize_observer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["resolveDirective"])("resize-observer");
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withDirectives"])((Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("div", {
              class: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeClass"])(["bunt-input", {
                focused: _ctx.focused,
                "floating-label": $options.floatingLabel,
                invalid: $options.invalid,
                disabled: $props.disabled,
                "with-icon": $props.icon
              }]),
              style: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeStyle"])({
                "--label-gap": _ctx.floatingLabelWidth
              })
            }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("div", inputvue_type_template_id_d2b370f8_lang_pug_hoisted_1, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("label", {
              for: $props.name
            }, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toDisplayString"])($props.label), 9, inputvue_type_template_id_d2b370f8_lang_pug_hoisted_2), $props.icon ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("div", {
              key: 0,
              class: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeClass"])(["icon mdi", [$options.iconClass]])
            }, null, 2)) : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("input", {
              ref: "input",
              type: $props.type,
              name: $props.name,
              value: $props.modelValue,
              disabled: $props.disabled,
              readonly: $props.readonly,
              onInput: _cache[0] || (_cache[0] = ($event) => $options.onInput($event)),
              onFocus: _cache[1] || (_cache[1] = ($event) => _ctx.focused = true),
              onBlur: _cache[2] || (_cache[2] = (...args) => $options.onBlur && $options.onBlur(...args)),
              placeholder: $props.placeholder
            }, null, 40, inputvue_type_template_id_d2b370f8_lang_pug_hoisted_3), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withDirectives"])(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("div", {
              class: "error-icon mdi mdi-alert-circle",
              title: $options.hintText
            }, null, 8, inputvue_type_template_id_d2b370f8_lang_pug_hoisted_4), [[external_commonjs_vue_commonjs2_vue_root_Vue_["vShow"], $options.invalid]]), (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("svg", inputvue_type_template_id_d2b370f8_lang_pug_hoisted_5, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("path", {
              d: _ctx.outlineStroke
            }, null, 8, _hoisted_6)], 512))]), $props.hintIsHtml ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("div", {
              key: 0,
              class: "hint",
              innerHTML: $options.hintText
            }, null, 8, _hoisted_7)) : (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("div", _hoisted_8, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toDisplayString"])($options.hintText), 1))], 6)), [[_directive_resize_observer, _ctx.generateOutline]]);
          }
          const measuringCanvas = typeof window !== "undefined" && document.createElement("canvas");
          function getTextMetrics(text, font) {
            if (typeof window === "undefined")
              return 0;
            var context = measuringCanvas.getContext("2d");
            context.font = font;
            return context.measureText(text || "");
          }
          var input_outline = {
            data: function() {
              return {
                outlineStroke: ""
              };
            },
            computed: {
              floatingLabelWidth() {
                return this.label ? getTextMetrics(this.label, `12px 'Roboto', "Helvetica Neue", HelveticaNeue, Helvetica, Arial, sans-serif`).width + 8 : 0;
              }
            },
            mounted() {
              this.$nextTick(() => {
                this.generateOutline();
              });
            },
            methods: {
              generateOutline() {
                const {
                  width,
                  height
                } = this.$refs.outline.getBoundingClientRect();
                const radius = 4;
                const cornerWidth = radius + 1;
                this.outlineStroke = `M ${cornerWidth} 1
			h ${width - 2 * cornerWidth}
			a ${radius} ${radius} 0 0 1 ${radius} ${radius}
			v ${height - 2 * cornerWidth}
			a ${radius} ${radius} 0 0 1 ${-radius} ${radius}
			h ${-width + 2 * cornerWidth}
			a ${radius} ${radius} 0 0 1 ${-radius} ${-radius}
			v ${-height + 2 * cornerWidth}
			a ${radius} ${radius} 0 0 1 ${radius} ${-radius}`;
              }
            }
          };
          var inputvue_type_script_lang_js = {
            name: `bunt-input`,
            mixins: [input_outline],
            props: {
              type: {
                type: String,
                default: "text"
              },
              name: {
                type: String,
                required: true
              },
              label: String,
              placeholder: String,
              modelValue: {
                type: [String, Number],
                default: ""
              },
              disabled: {
                type: Boolean,
                default: false
              },
              readonly: {
                type: Boolean,
                default: false
              },
              icon: String,
              iconRight: {
                type: Boolean,
                default: false
              },
              hint: String,
              hintIsHtml: {
                type: Boolean,
                default: false
              },
              validation: Object
              // vuelidate result
            },
            emits: ["update:modelValue"],
            data: function() {
              return {
                focused: false
              };
            },
            computed: {
              iconClass() {
                return icon.getClass(this.icon);
              },
              invalid() {
                return this.validation && this.validation.$error;
              },
              hintText() {
                if (this.invalid && this.validation.$errors) {
                  const errorMessages2 = this.validation.$errors.map((error) => error.$message);
                  return errorMessages2.filter(Boolean).join();
                }
                return this.hint;
              },
              floatingLabel() {
                return Boolean(this.placeholder || this.modelValue || this.modelValue === 0);
              }
            },
            methods: {
              onInput($event) {
                this.$emit("update:modelValue", $event.target.value);
                if (this.validation)
                  this.validation.$touch();
              },
              onBlur() {
                this.focused = false;
                if (this.validation)
                  this.validation.$touch();
              }
            }
          };
          inputvue_type_script_lang_js.render = inputvue_type_template_id_d2b370f8_lang_pug_render;
          var input = inputvue_type_script_lang_js;
          const input_outline_containervue_type_template_id_346284ce_lang_pug_hoisted_1 = {
            class: "outline",
            ref: "outline"
          };
          const input_outline_containervue_type_template_id_346284ce_lang_pug_hoisted_2 = ["d"];
          function input_outline_containervue_type_template_id_346284ce_lang_pug_render(_ctx, _cache, $props, $setup, $data, $options) {
            const _directive_resize_observer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["resolveDirective"])("resize-observer");
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withDirectives"])((Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("div", {
              class: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeClass"])(["bunt-input-outline-container", {
                focused: $data.focused
              }]),
              style: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeStyle"])({
                "--label-gap": _ctx.floatingLabelWidth
              })
            }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("label", null, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toDisplayString"])($props.label), 1), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default", {
              focus: $options.focus,
              blur: $options.blur
            }), (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("svg", input_outline_containervue_type_template_id_346284ce_lang_pug_hoisted_1, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("path", {
              d: _ctx.outlineStroke
            }, null, 8, input_outline_containervue_type_template_id_346284ce_lang_pug_hoisted_2)], 512))], 6)), [[_directive_resize_observer, _ctx.generateOutline]]);
          }
          var input_outline_containervue_type_script_lang_js = {
            name: `bunt-input-outline-container`,
            mixins: [input_outline],
            props: {
              label: String
            },
            data() {
              return {
                focused: false
              };
            },
            computed: {},
            created() {
            },
            mounted() {
              this.$nextTick(() => {
              });
            },
            methods: {
              focus() {
                this.focused = true;
              },
              blur() {
                this.focused = false;
              }
            }
          };
          input_outline_containervue_type_script_lang_js.render = input_outline_containervue_type_template_id_346284ce_lang_pug_render;
          var input_outline_container = input_outline_containervue_type_script_lang_js;
          const link_buttonvue_type_template_id_17bdf0df_lang_pug_hoisted_1 = ["href", "onClick"];
          function link_buttonvue_type_template_id_17bdf0df_lang_pug_render(_ctx, _cache, $props, $setup, $data, $options) {
            const _component_ripple_ink = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["resolveComponent"])("ripple-ink");
            const _component_router_link = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["resolveComponent"])("router-link");
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createBlock"])(_component_router_link, {
              to: $props.to,
              custom: ""
            }, {
              default: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withCtx"])(({
                href,
                navigate
              }) => [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("a", Object(external_commonjs_vue_commonjs2_vue_root_Vue_["mergeProps"])({
                class: "bunt-link-button"
              }, _ctx.$attrs, {
                href,
                onClick: ($event) => {
                  navigate($event);
                  _ctx.$emit("click", $event);
                }
              }), [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default"), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(_component_ripple_ink)], 16, link_buttonvue_type_template_id_17bdf0df_lang_pug_hoisted_1)]),
              _: 3
            }, 8, ["to"]);
          }
          var link_buttonvue_type_script_lang_js = {
            name: `bunt-link-button`,
            components: {},
            mixins: [mixins_ripple_ink],
            props: {
              to: Object
            },
            emits: ["click"]
          };
          link_buttonvue_type_script_lang_js.render = link_buttonvue_type_template_id_17bdf0df_lang_pug_render;
          var link_button = link_buttonvue_type_script_lang_js;
          const selectvue_type_template_id_66eb8d77_lang_pug_hoisted_1 = {
            class: "label-input-container"
          };
          const selectvue_type_template_id_66eb8d77_lang_pug_hoisted_2 = ["for"];
          const selectvue_type_template_id_66eb8d77_lang_pug_hoisted_3 = ["name", "disabled", "placeholder"];
          const selectvue_type_template_id_66eb8d77_lang_pug_hoisted_4 = {
            class: "outline",
            ref: "outline"
          };
          const selectvue_type_template_id_66eb8d77_lang_pug_hoisted_5 = ["d"];
          const selectvue_type_template_id_66eb8d77_lang_pug_hoisted_6 = ["innerHTML"];
          const selectvue_type_template_id_66eb8d77_lang_pug_hoisted_7 = {
            key: 1,
            class: "hint"
          };
          const selectvue_type_template_id_66eb8d77_lang_pug_hoisted_8 = {
            class: "scrollable-menu"
          };
          const _hoisted_9 = ["onMouseover", "onClick"];
          const _hoisted_10 = {
            key: 0,
            class: "divider",
            transition: "fade"
          };
          const _hoisted_11 = {
            key: 1,
            class: "text-center",
            transition: "fade"
          };
          function selectvue_type_template_id_66eb8d77_lang_pug_render(_ctx, _cache, $props, $setup, $data, $options) {
            const _directive_scrollbar = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["resolveDirective"])("scrollbar");
            const _directive_resize_observer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["resolveDirective"])("resize-observer");
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withDirectives"])((Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("div", {
              class: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeClass"])(["bunt-select dropdown", $options.dropdownClasses])
            }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("div", {
              class: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeClass"])(["bunt-input dense", {
                focused: $data.open,
                "floating-label": $data.rawSearch.length != 0 || !$options.isValueEmpty,
                invalid: $options.invalid,
                disabled: $props.disabled
              }]),
              ref: "searchContainer",
              style: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeStyle"])({
                "--label-gap": _ctx.floatingLabelWidth
              })
            }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("div", selectvue_type_template_id_66eb8d77_lang_pug_hoisted_1, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("label", {
              for: $props.name
            }, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toDisplayString"])($props.label), 9, selectvue_type_template_id_66eb8d77_lang_pug_hoisted_2), $props.icon ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("div", {
              key: 0,
              class: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeClass"])(["icon mdi", [$options.iconClass]])
            }, null, 2)) : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withDirectives"])(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("input", {
              type: "text",
              ref: "search",
              name: $props.name,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.rawSearch = $event),
              disabled: $props.disabled,
              onKeydown: [_cache[1] || (_cache[1] = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withKeys"])((...args) => $options.maybeDeleteValue && $options.maybeDeleteValue(...args), ["delete"])), _cache[3] || (_cache[3] = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withKeys"])(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withModifiers"])((...args) => _ctx.typeAheadUp && _ctx.typeAheadUp(...args), ["prevent"]), ["up"])), _cache[4] || (_cache[4] = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withKeys"])(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withModifiers"])((...args) => _ctx.typeAheadDown && _ctx.typeAheadDown(...args), ["prevent"]), ["down"]))],
              onKeyup: [_cache[2] || (_cache[2] = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withKeys"])((...args) => $options.onEscape && $options.onEscape(...args), ["esc"])), _cache[5] || (_cache[5] = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withKeys"])(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withModifiers"])((...args) => _ctx.typeAheadSelect && _ctx.typeAheadSelect(...args), ["prevent"]), ["enter"]))],
              onBlur: _cache[6] || (_cache[6] = (...args) => $options.blur && $options.blur(...args)),
              onFocus: _cache[7] || (_cache[7] = (...args) => $options.focus && $options.focus(...args)),
              placeholder: $options.searchPlaceholder,
              autocomplete: "off"
            }, null, 40, selectvue_type_template_id_66eb8d77_lang_pug_hoisted_3), [[external_commonjs_vue_commonjs2_vue_root_Vue_["vModelText"], $data.rawSearch]]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("i", {
              class: "open-indicator mdi mdi-menu-down",
              ref: "openIndicator",
              role: "presentation",
              onMousedown: _cache[8] || (_cache[8] = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withModifiers"])(() => {
              }, ["prevent", "stop"])),
              onClick: _cache[9] || (_cache[9] = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withModifiers"])((...args) => $options.toggleDropdown && $options.toggleDropdown(...args), ["prevent", "stop"]))
            }, null, 544), (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("svg", selectvue_type_template_id_66eb8d77_lang_pug_hoisted_4, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("path", {
              d: _ctx.outlineStroke
            }, null, 8, selectvue_type_template_id_66eb8d77_lang_pug_hoisted_5)], 512))]), $props.hintIsHtml ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("div", {
              key: 0,
              class: "hint",
              innerHTML: $options.hintText
            }, null, 8, selectvue_type_template_id_66eb8d77_lang_pug_hoisted_6)) : (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("div", selectvue_type_template_id_66eb8d77_lang_pug_hoisted_7, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toDisplayString"])($options.hintText), 1))], 6), $data.open ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createBlock"])(external_commonjs_vue_commonjs2_vue_root_Vue_["Teleport"], {
              key: 0,
              to: "#bunt-teleport-target"
            }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("div", {
              class: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeClass"])(["bunt-select-dropdown-menu", [$props.dropdownClass]]),
              ref: "dropdownMenu",
              style: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeStyle"])({
                "max-height": $props.maxHeight,
                "width": $data.width + "px"
              }),
              onMousedown: _cache[10] || (_cache[10] = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withModifiers"])(() => {
              }, ["prevent", "stop"]))
            }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "result-header"), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withDirectives"])((Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("div", selectvue_type_template_id_66eb8d77_lang_pug_hoisted_8, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("ul", null, [(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(true), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])(external_commonjs_vue_commonjs2_vue_root_Vue_["Fragment"], null, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderList"])($options.filteredOptions, (option, index) => {
              return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("li", {
                key: index,
                class: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeClass"])({
                  active: $options.isOptionSelected(option),
                  highlight: index === _ctx.typeAheadPointer
                }),
                onMouseover: ($event) => _ctx.typeAheadPointer = index,
                onClick: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withModifiers"])(($event) => $options.select(option), ["prevent", "stop"])
              }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default", {
                option
              }, () => [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createTextVNode"])(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toDisplayString"])($props.getOptionLabel(option)), 1)])], 42, _hoisted_9);
            }), 128)), !$options.filteredOptions.length ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("li", _hoisted_10)) : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true), !$options.filteredOptions.length ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("li", _hoisted_11, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "no-options", {}, () => [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createTextVNode"])("Sorry, no matching options.")])])) : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true)])])), [[_directive_scrollbar, {
              _preventMousedown: true
            }, void 0, {
              y: true
            }]])], 38)])) : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true)], 2)), [[_directive_resize_observer, _ctx.generateOutline]]);
          }
          var pointer_scroll = {
            watch: {
              typeAheadPointer() {
                this.maybeAdjustScroll();
              }
            },
            methods: {
              /**
                 * Adjust the scroll position of the dropdown list
                 * if the current pointer is outside of the
                 * overflow bounds.
                 * @returns {*}
                 */
              maybeAdjustScroll() {
                if (!this.$refs.dropdownMenu)
                  return;
                let pixelsToPointerTop = this.pixelsToPointerTop();
                let pixelsToPointerBottom = this.pixelsToPointerBottom();
                if (pixelsToPointerTop <= this.viewport().top) {
                  return this.scrollTo(pixelsToPointerTop);
                } else if (pixelsToPointerBottom >= this.viewport().bottom) {
                  return this.scrollTo(this.viewport().top + this.pointerHeight());
                }
              },
              /**
                 * The distance in pixels from the top of the dropdown
                 * list to the top of the current pointer element.
                 * @returns {number}
                 */
              pixelsToPointerTop() {
                let pixelsToPointerTop = 0;
                let elements = this.$refs.dropdownMenu.children;
                for (let i = 0; i < this.typeAheadPointer; i++) {
                  pixelsToPointerTop += elements[i] ? elements[i].offsetHeight : 0;
                }
                return pixelsToPointerTop;
              },
              /**
                 * The distance in pixels from the top of the dropdown
                 * list to the bottom of the current pointer element.
                 * @returns {*}
                 */
              pixelsToPointerBottom() {
                return this.pixelsToPointerTop() + this.pointerHeight();
              },
              /**
                 * The offsetHeight of the current pointer element.
                 * @returns {number}
                 */
              pointerHeight() {
                let element = this.$refs.dropdownMenu.children[this.typeAheadPointer];
                return element ? element.offsetHeight : 0;
              },
              /**
                 * The currently viewable portion of the dropdownMenu.
                 * @returns {{top: (string|*|number), bottom: *}}
                 */
              viewport() {
                return {
                  top: this.$refs.dropdownMenu.scrollTop,
                  bottom: this.$refs.dropdownMenu.offsetHeight + this.$refs.dropdownMenu.scrollTop
                };
              },
              /**
                 * Scroll the dropdownMenu to a given position.
                 * @param position
                 * @returns {*}
                 */
              scrollTo(position) {
                return this.$refs.dropdownMenu.scrollTop = position;
              }
            }
          };
          var type_ahead_pointer = {
            data() {
              return {
                typeAheadPointer: -1
              };
            },
            watch: {
              filteredOptions() {
                this.typeAheadPointer = 0;
              }
            },
            methods: {
              /**
                 * Move the typeAheadPointer visually up the list by
                 * subtracting the current index by one.
                 * @return {void}
                 */
              typeAheadUp() {
                if (this.typeAheadPointer > 0) {
                  this.typeAheadPointer--;
                  if (this.maybeAdjustScroll) {
                    this.maybeAdjustScroll();
                  }
                }
              },
              /**
                 * Move the typeAheadPointer visually down the list by
                 * adding the current index by one.
                 * @return {void}
                 */
              typeAheadDown() {
                if (this.typeAheadPointer < this.filteredOptions.length - 1) {
                  this.typeAheadPointer++;
                  if (this.maybeAdjustScroll) {
                    this.maybeAdjustScroll();
                  }
                }
              },
              /**
                 * Select the option at the current typeAheadPointer position.
                 * Optionally clear the search input on selection.
                 * @return {void}
                 */
              typeAheadSelect() {
                if (this.filteredOptions[this.typeAheadPointer]) {
                  this.select(this.filteredOptions[this.typeAheadPointer]);
                } else if (this.taggable && this.search.length) {
                  this.select(this.search);
                }
              }
            }
          };
          var fuzzysearch = __webpack_require__("2e39");
          var fuzzysearch_default = __webpack_require__.n(fuzzysearch);
          var selectvue_type_script_lang_js = {
            name: `bunt-select`,
            mixins: [input_outline, type_ahead_pointer, pointer_scroll],
            props: {
              name: {
                type: String,
                required: true
              },
              label: String,
              modelValue: {
                type: [String, Object, Number],
                default: null
              },
              icon: String,
              /**
               * An array of strings or objects to be used as dropdown choices.
               * If you are using an array of objects, vue-select will look for
               * a `label` key (ex. [{label: 'This is Foo', value: 'foo'}]). A
               * custom label key can be set with the `optionLabel` prop.
               * @type {Object}
               */
              options: {
                type: Array,
                default() {
                  return [];
                }
              },
              placeholder: {
                type: String,
                default: ""
              },
              disabled: {
                type: Boolean,
                default: false
              },
              maxHeight: {
                type: String,
                default: "400px"
              },
              /**
               * Tells vue-select what key to use when generating option
               * labels when each `option` is an object.
               * @type {String}
               */
              optionLabel: {
                type: String,
                default: "label"
              },
              /**
               * Callback to generate the label text. If {option}
               * is an object, returns option[this.optionLabel] by default.
               * @param  {(string|Object)} option
               * @return {String}
               */
              getOptionLabel: {
                type: Function,
                default(option) {
                  if (typeof option === "object") {
                    if (this.optionLabel !== void 0 && option[this.optionLabel] !== void 0) {
                      return option[this.optionLabel];
                    }
                  }
                  return option;
                }
              },
              optionValue: {
                type: String,
                default: "id"
              },
              getOptionValue: {
                type: Function,
                default(option) {
                  if (typeof option === "object") {
                    if (this.optionValue !== void 0 && option[this.optionValue] !== void 0) {
                      return option[this.optionValue];
                    }
                  }
                  return option;
                }
              },
              findOptionByValue: {
                type: Function,
                default(value) {
                  const findFunc = (option) => {
                    if (typeof option === "object" && this.optionValue)
                      return option[this.optionValue] === value;
                    return option === value;
                  };
                  return this.options.find(findFunc);
                }
              },
              hint: String,
              hintIsHtml: {
                type: Boolean,
                default: false
              },
              validation: Object,
              // vuelidate result
              dropdownClass: String,
              dropdownOverflowElement: [String, Object],
              filterByFunction: {
                type: Function,
                default(lowercasedSearch, option, fuzzyFn) {
                  return fuzzyFn(lowercasedSearch, this.getOptionLabel(option).toLowerCase());
                }
              }
            },
            emits: ["update:modelValue", "blur"],
            data() {
              return {
                search: "",
                rawSearch: "",
                open: false,
                width: 0
              };
            },
            computed: {
              /**
               * Classes to be output on .dropdown
               * @return {Object}
               */
              dropdownClasses() {
                return {
                  open: this.open
                };
              },
              /**
               * Return the placeholder string if it's set
               * & there is no value selected.
               * @return {String} Placeholder text
               */
              searchPlaceholder() {
                if (this.isValueEmpty && this.placeholder) {
                  return this.placeholder;
                }
              },
              /**
               * The currently displayed options, filtered
               * by the search elements value. If tagging
               * true, the search text will be prepended
               * if it doesn't already exist.
               *
               * @return {array}
               */
              filteredOptions() {
                if (!this.search)
                  return this.options;
                return this.options.filter((option) => this.filterByFunction(this.search.toLowerCase(), option, fuzzysearch_default.a));
              },
              /**
               * Check if there aren't any options selected.
               * @return {Boolean}
               */
              isValueEmpty() {
                if (this.modelValue) {
                  if (typeof this.modelValue === "object") {
                    return !Object.keys(this.modelValue).length;
                  }
                  return !this.modelValue.length;
                }
                return true;
              },
              iconClass() {
                return icon.getClass(this.icon);
              },
              invalid() {
                return this.validation && this.validation.$error;
              },
              hintText() {
                if (this.invalid && this.validation.$errors) {
                  const errorMessages2 = this.validation.$errors.map((error) => error.$message);
                  return errorMessages2.filter(Boolean).join();
                }
                return this.hint;
              }
            },
            watch: {
              modelValue(value) {
                this.selectValue(value);
              },
              rawSearch(val) {
                if (this.open)
                  this.search = val;
              },
              filteredOptions() {
                var _this$_popper;
                (_this$_popper = this._popper) === null || _this$_popper === void 0 ? void 0 : _this$_popper.scheduleUpdate();
              }
            },
            mounted() {
              this.selectValue(this.modelValue);
            },
            beforeUnmount() {
              var _this$_popper2;
              (_this$_popper2 = this._popper) === null || _this$_popper2 === void 0 ? void 0 : _this$_popper2.destroy();
            },
            methods: {
              async focus() {
                this.open = true;
                this.search = "";
                this.$refs.search.select();
                this.width = this.$refs.searchContainer.getBoundingClientRect().width;
                await this.$nextTick();
                const options = {
                  placement: "bottom",
                  positionFixed: true,
                  modifiers: {}
                };
                if (this.icon) {
                  options.modifiers.offset = {
                    offset: "-15, 0"
                  };
                }
                if (this.dropdownOverflowElement) {
                  options.modifiers.preventOverflow = {
                    boundariesElement: this.dropdownOverflowElement
                  };
                }
                this._popper = new popper[
                  "a"
                  /* default */
                ](this.$refs.search, this.$refs.dropdownMenu, options);
              },
              blur(event) {
                this.open = false;
                this.$nextTick(() => {
                  var _this$_popper3;
                  return (_this$_popper3 = this._popper) === null || _this$_popper3 === void 0 ? void 0 : _this$_popper3.destroy();
                });
                if (this.validation)
                  this.validation.$touch();
                this.$emit("blur");
              },
              selectValue(value) {
                const option = this.findOptionByValue(value);
                this.rawSearch = this.getOptionLabel(option) || "";
              },
              /**
               * Select a given option.
               * @param  {(string|Object)} option
               * @return {void}
               */
              select(option) {
                if (this.isOptionSelected(option)) {
                  this.deselect(option);
                } else {
                  this.$emit("update:modelValue", this.getOptionValue(option));
                }
                this.onAfterSelect(option);
              },
              /**
               * De-select a given option.
               * @param  {(string|Object)} option
               * @return {void}
               */
              deselect(option) {
                this.$emit("update:modelValue", null);
              },
              /**
               * Called from this.select after each selection.
               * @param  {(string|Object)} option
               * @return {void}
               */
              onAfterSelect(option) {
                this.$refs.search.blur();
                this.rawSearch = this.getOptionLabel(option) || "";
              },
              /**
               * Toggle the visibility of the dropdown menu.
               * @param  {Event} e
               * @return {void}
               */
              toggleDropdown(e) {
                if (e.target === this.$refs.openIndicator || e.target === this.$refs.search || e.target === this.$refs.toggle || e.target === this.$el) {
                  if (!this.open) {
                    this.$refs.search.focus();
                  } else {
                    this.$refs.search.blur();
                  }
                }
              },
              /**
               * Check if the given option is currently selected.
               * @param  {(string|Object)}  option
               * @return {Boolean}         True when selected || False otherwise
               */
              isOptionSelected(option) {
                return this.modelValue === option;
              },
              /**
               * If there is any text in the search input, remove it.
               * Otherwise, blur the search input to close the dropdown.
               * @return {[type]} [description]
               */
              onEscape() {
                if (!this.rawSearch.length) {
                  this.$refs.search.blur();
                } else {
                  this.deselect();
                  this.rawSearch = "";
                }
              },
              /**
               * Delete the value on Delete keypress when there is no
               * text in the search input, & there's tags to delete
               * @return {this.value}
               */
              maybeDeleteValue() {
                if (!this.$refs.search.value.length && this.modelValue) {
                  this.$emit("update:modelValue", null);
                }
              }
            }
          };
          selectvue_type_script_lang_js.render = selectvue_type_template_id_66eb8d77_lang_pug_render;
          var src_select = selectvue_type_script_lang_js;
          const switchvue_type_template_id_4ddf677a_lang_pug_hoisted_1 = ["name", "checked", "disabled", "readonly"];
          const switchvue_type_template_id_4ddf677a_lang_pug_hoisted_2 = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("div", {
            class: "bunt-switch-track"
          }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("div", {
            class: "bunt-switch-thumb"
          })], -1);
          function switchvue_type_template_id_4ddf677a_lang_pug_render(_ctx, _cache, $props, $setup, $data, $options) {
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("div", {
              class: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeClass"])(["bunt-switch", {
                checked: $props.modelValue
              }])
            }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("input", {
              type: "checkbox",
              name: $props.name,
              checked: $props.modelValue,
              disabled: $props.disabled,
              readonly: $props.readonly,
              onChange: _cache[0] || (_cache[0] = ($event) => $options.onChange($event)),
              onFocus: _cache[1] || (_cache[1] = ($event) => $data.focused = true),
              onBlur: _cache[2] || (_cache[2] = (...args) => $options.onBlur && $options.onBlur(...args))
            }, null, 40, switchvue_type_template_id_4ddf677a_lang_pug_hoisted_1), switchvue_type_template_id_4ddf677a_lang_pug_hoisted_2, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("label", null, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toDisplayString"])($props.label), 1)], 2);
          }
          var switchvue_type_script_lang_js = {
            name: `bunt-switch`,
            components: {},
            props: {
              modelValue: {
                type: Boolean,
                default: false
              },
              name: {
                type: String,
                required: true
              },
              label: String,
              disabled: {
                type: Boolean,
                default: false
              },
              readonly: {
                type: Boolean,
                default: false
              }
            },
            emits: ["update:modelValue"],
            data() {
              return {
                focused: false
              };
            },
            methods: {
              onChange($event) {
                this.$emit("update:modelValue", $event.target.checked);
                if (this.validation)
                  this.validation.$touch();
              },
              onBlur() {
                this.focused = false;
                if (this.validation)
                  this.validation.$touch();
              }
            }
          };
          switchvue_type_script_lang_js.render = switchvue_type_template_id_4ddf677a_lang_pug_render;
          var src_switch = switchvue_type_script_lang_js;
          const tab_headervue_type_template_id_da3c5430_lang_pug_hoisted_1 = ["tabindex", "aria-controls", "aria-selected", "disabled"];
          const tab_headervue_type_template_id_da3c5430_lang_pug_hoisted_2 = {
            key: 0,
            class: "bunt-tab-header-item-icon"
          };
          const tab_headervue_type_template_id_da3c5430_lang_pug_hoisted_3 = ["textContent"];
          function tab_headervue_type_template_id_da3c5430_lang_pug_render(_ctx, _cache, $props, $setup, $data, $options) {
            const _component_ripple_ink = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["resolveComponent"])("ripple-ink");
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("li", {
              class: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeClass"])(["bunt-tab-header-item", ["type-" + $props.type, {
                "active": $props.active,
                "disabled": $props.disabled
              }]]),
              role: "tab",
              tabindex: $props.active ? 0 : -1,
              "aria-controls": $props.id,
              "aria-selected": $props.active ? "true" : null,
              disabled: $props.disabled,
              ref: "item"
            }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default", {}, () => [$props.type === "icon" || $props.type === "icon-and-text" ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("div", tab_headervue_type_template_id_da3c5430_lang_pug_hoisted_2, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("i", {
              class: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeClass"])(["bunt-icon mdi", [$options.iconClass]])
            }, null, 2)])) : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true), $props.type === "text" || $props.type === "icon-and-text" ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("div", {
              key: 1,
              class: "bunt-tab-header-item-text",
              textContent: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toDisplayString"])($props.text)
            }, null, 8, tab_headervue_type_template_id_da3c5430_lang_pug_hoisted_3)) : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true)]), !$props.disabled ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createBlock"])(_component_ripple_ink, {
              key: 0
            })) : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true)], 10, tab_headervue_type_template_id_da3c5430_lang_pug_hoisted_1);
          }
          var tab_headervue_type_script_lang_js = {
            name: `bunt-tab-header-item`,
            mixins: [mixins_ripple_ink],
            props: {
              id: String,
              type: {
                type: String,
                default: "text"
                // 'text', 'icon', or 'icon-and-text'
              },
              text: String,
              icon: String,
              active: {
                type: Boolean,
                default: false
              },
              disabled: {
                type: Boolean,
                default: false
              }
            },
            computed: {
              iconClass() {
                return icon.getClass(this.icon);
              }
            }
          };
          tab_headervue_type_script_lang_js.render = tab_headervue_type_template_id_da3c5430_lang_pug_render;
          var tab_header = tab_headervue_type_script_lang_js;
          const filterTabs = function(vnodes) {
            if (vnodes.length === 1 && vnodes[0].type === external_commonjs_vue_commonjs2_vue_root_Vue_["Fragment"])
              return filterTabs(vnodes[0].children);
            return vnodes.filter((tab) => tab.type.name === "bunt-tab");
          };
          var tabs = {
            name: `bunt-tabs`,
            props: {
              type: {
                type: String,
                default: "text"
                // 'text', 'icon', or 'icon-and-text'styleObject
              },
              modelValue: {
                type: [Number, String, Object, Function]
              }
            },
            emits: ["update:modelValue"],
            setup(props, {
              slots,
              emit
            }) {
              const state = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["reactive"])({
                tabs: filterTabs(slots.default()),
                activeTab: null,
                indicatorTargetTransform: null,
                indicatorState: null,
                indicatorTransform: null,
                indicatorStyle: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(() => {
                  if (!state.indicatorTransform)
                    return;
                  return {
                    transform: `translateX(${state.indicatorTransform.left}%) scaleX(${state.indicatorTransform.width})`
                  };
                })
              });
              const $el = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
              const tabsContainer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
              const tabElements = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])([]);
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUpdate"])(() => {
                tabElements.value = [];
              });
              const getTabValue = (tab) => tab ? tab.props.id || state.tabs.indexOf(tab) : null;
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(() => slots.default(), (els) => {
                state.tabs = filterTabs(els);
                let index = tabElements.value.findIndex((tab) => tab.id === state.activeTab);
                if (index < 0 && props.modelValue === void 0)
                  index = 0;
                select(index);
              }, {
                flush: "post"
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(() => props.modelValue, () => {
                if (getTabValue(state.activeTab) === props.modelValue)
                  return;
                select(tabElements.value.findIndex((tab) => tab.id === props.modelValue));
              });
              const animateIndicator = (index, oldIndex) => {
                if (index == null || index < 0) {
                  state.indicatorTransform = {
                    width: 0,
                    left: 0
                  };
                  return;
                }
                let rect = tabsContainer.value.getBoundingClientRect();
                let width = rect.width;
                const elements = Array.from(tabsContainer.value.children);
                let tabRect = tabElements.value[index].$el.getBoundingClientRect();
                let tabOffsetLeft = tabRect.left - rect.left;
                state.indicatorTargetTransform = {
                  width: tabRect.width / width,
                  left: tabOffsetLeft / width * 100
                };
                if (oldIndex === void 0 || oldIndex < 0) {
                  state.indicatorState = "";
                  state.indicatorTransform = {
                    width: state.indicatorTargetTransform.width,
                    left: state.indicatorTargetTransform.left
                  };
                } else {
                  const oldRect = tabElements.value[oldIndex].$el.getBoundingClientRect();
                  state.indicatorState = "expand";
                  if (oldIndex < index) {
                    state.indicatorTransform.width = (tabRect.left + tabRect.width - oldRect.left) / width;
                  } else {
                    state.indicatorTransform = {
                      width: (oldRect.left + oldRect.width - tabRect.left) / width,
                      left: tabOffsetLeft / width * 100
                    };
                  }
                }
              };
              const select = (idOrIndex) => {
                var _state$activeTab, _state$activeTab$prop3, _state$activeTab$prop4;
                const activeTab = state.tabs.find((tab) => tab.props.id === idOrIndex) || state.tabs[idOrIndex];
                const index = state.tabs.indexOf(activeTab);
                const oldIndex = state.tabs.indexOf(state.activeTab);
                const oldValue = getTabValue(state.activeTab);
                if (oldValue) {
                  var _state$activeTab$prop, _state$activeTab$prop2;
                  (_state$activeTab$prop = (_state$activeTab$prop2 = state.activeTab.props).onDeselected) === null || _state$activeTab$prop === void 0 ? void 0 : _state$activeTab$prop.call(_state$activeTab$prop2, oldValue);
                }
                state.activeTab = activeTab;
                const newValue = getTabValue(state.activeTab);
                if (newValue !== props.modelValue) {
                  emit("update:modelValue", newValue);
                }
                (_state$activeTab = state.activeTab) === null || _state$activeTab === void 0 ? void 0 : (_state$activeTab$prop3 = (_state$activeTab$prop4 = _state$activeTab.props).onSelected) === null || _state$activeTab$prop3 === void 0 ? void 0 : _state$activeTab$prop3.call(_state$activeTab$prop4, newValue);
                animateIndicator(index, oldIndex);
              };
              let observer;
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(() => {
                select(props.modelValue || 0);
                observer = new ResizeObserver_es[
                  "a"
                  /* default */
                ]((entries) => {
                  if (tabsContainer.value && state.activeTab)
                    animateIndicator(state.tabs.indexOf(state.activeTab));
                });
                observer.observe($el.value);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUnmount"])(() => {
                observer.disconnect();
              });
              return () => {
                var _state$activeTab2, _state$activeTab3, _state$activeTab3$chi;
                return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
                  class: "bunt-tabs",
                  ref: $el
                }, [
                  Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
                    class: "bunt-tabs-header"
                  }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("ul", {
                    class: "bunt-tabs-header-items",
                    role: "tablist",
                    ref: tabsContainer
                  }, state.tabs.map((tab, index) => {
                    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(tab_header, {
                      id: tab.props.id,
                      text: typeof tab.props.header === "string" ? tab.props.header : null,
                      active: tab === state.activeTab,
                      disabled: tab.props.disabled,
                      key: tab.props.id,
                      ref(el) {
                        if (!el)
                          return;
                        tabElements.value[index] = el;
                      },
                      onClick() {
                        if (tab.props.disabled)
                          return;
                        select(index, state.tabs);
                      }
                    }, slots.headerItem ? () => slots.headerItem({
                      id: tab.props.id,
                      ...tab.props.header
                    }) : null);
                  })), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
                    class: ["bunt-tabs-indicator", state.indicatorState],
                    style: state.indicatorStyle,
                    onTransitionend() {
                      if (state.indicatorState === "expand") {
                        state.indicatorState = "contract";
                        state.indicatorTransform = {
                          width: state.indicatorTargetTransform.width,
                          left: state.indicatorTargetTransform.left
                        };
                      } else {
                        state.indicatorState = "";
                      }
                    }
                  })]),
                  Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
                    class: "bunt-tabs-body",
                    role: "tabpanel",
                    tabindex: 0,
                    key: (_state$activeTab2 = state.activeTab) === null || _state$activeTab2 === void 0 ? void 0 : _state$activeTab2.props.id
                    // forces proper lifecycle of tab contents
                  }, (_state$activeTab3 = state.activeTab) === null || _state$activeTab3 === void 0 ? void 0 : (_state$activeTab3$chi = _state$activeTab3.children) === null || _state$activeTab3$chi === void 0 ? void 0 : _state$activeTab3$chi.default())
                  // just activeTab does not seem to work
                ]);
              };
            }
          };
          function tabvue_type_template_id_c212eb12_lang_pug_render(_ctx, _cache, $props, $setup, $data, $options) {
            return null;
          }
          var tabvue_type_script_lang_js = {
            name: `bunt-tab`,
            props: {
              header: [String, Object],
              icon: String,
              disabled: {
                type: Boolean,
                default: false
              },
              id: String
            },
            emits: ["selected", "deselected"]
          };
          tabvue_type_script_lang_js.render = tabvue_type_template_id_c212eb12_lang_pug_render;
          var src_tab = tabvue_type_script_lang_js;
          const dialogvue_type_template_id_818c3a12_lang_pug_hoisted_1 = {
            key: 0,
            class: "bunt-dialog-container"
          };
          const dialogvue_type_template_id_818c3a12_lang_pug_hoisted_2 = {
            class: "bunt-dialog"
          };
          function dialogvue_type_template_id_818c3a12_lang_pug_render(_ctx, _cache, $props, $setup, $data, $options) {
            return $props.open ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("div", dialogvue_type_template_id_818c3a12_lang_pug_hoisted_1, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("div", dialogvue_type_template_id_818c3a12_lang_pug_hoisted_2, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default")]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("div", {
              class: "bunt-backdrop",
              onClick: _cache[0] || (_cache[0] = (...args) => $options.close && $options.close(...args)),
              "keyup.esc": "close"
            })])) : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
          }
          var dialogvue_type_script_lang_js = {
            props: {
              open: {
                type: Boolean,
                default: false
              }
            },
            emits: ["close"],
            mounted() {
              this.$nextTick(() => {
                document.body.appendChild(this.$el);
              });
            },
            beforeUnmount() {
              if (this.$el.parentNode === document.body) {
                document.body.removeChild(this.$el);
              }
            },
            methods: {
              close() {
                this.$emit("close");
              }
            }
          };
          dialogvue_type_script_lang_js.render = dialogvue_type_template_id_818c3a12_lang_pug_render;
          var dialog = dialogvue_type_script_lang_js;
          const lib = {
            install(Vue) {
              directives(Vue);
              Vue.component(`bunt-button`, src_button);
              Vue.component(`bunt-checkbox`, src_checkbox);
              Vue.component(`bunt-radio`, src_radio);
              Vue.component(`bunt-icon`, src_icon);
              Vue.component(`bunt-icon-button`, icon_button);
              Vue.component(`bunt-input`, input);
              Vue.component(`bunt-input-outline-container`, input_outline_container);
              Vue.component(`bunt-link-button`, link_button);
              Vue.component(`bunt-select`, src_select);
              Vue.component(`bunt-progress-circular`, progress_circular);
              Vue.component(`bunt-switch`, src_switch);
              Vue.component(`bunt-tabs`, tabs);
              Vue.component(`bunt-tab`, src_tab);
              Vue.component(`bunt-dialog`, dialog);
            }
          };
          var src_0 = lib;
          var entry_lib = __webpack_exports__["default"] = src_0;
        }
      )
      /******/
    });
  }
});
export default require_buntpapier_common();
/*! Bundled license information:

buntpapier/dist/buntpapier.common.js:
  (**!
  * @fileOverview Kickass library to create and place poppers near their reference elements.
  * @version 1.16.1
  * @license
  * Copyright (c) 2016 Federico Zivolo and contributors
  *
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
  * in the Software without restriction, including without limitation the rights
  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  * copies of the Software, and to permit persons to whom the Software is
  * furnished to do so, subject to the following conditions:
  *
  * The above copyright notice and this permission notice shall be included in all
  * copies or substantial portions of the Software.
  *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  * SOFTWARE.
  *)
*/
//# sourceMappingURL=buntpapier.js.map
